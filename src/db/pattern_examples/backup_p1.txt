
###===###.\convert2string.py

###===###.\tob64.py
import base64
import glob
#==SPACE==#

f_back = open("back.txt",'w', encoding='utf8')
#==SPACE==#

py_files = glob.glob("./**/*.py", recursive=True)+glob.glob("./**/*.js", recursive=True)+glob.glob("./**/*.css", recursive=True)+glob.glob("./**/*.html", recursive=True)+glob.glob("./**/*.ini", recursive=True)+glob.glob("./**/*.svg", recursive=True)+glob.glob("./**/*.json", recursive=True)
#==SPACE==#

for p in py_files:
    print(p)
#==SPACE==#

for py_file in py_files:
    f_back.write("\n###===###"+py_file+'\n')
    l = open(py_file, encoding='utf8').readlines()
    for line in l:
        if len(line.strip())==0:
            f_back.write("#==SPACE==#\n")
        f_back.write(line)
#==SPACE==#

f_back.close()
input()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#data = open("_backup.rar",'rb').read()
#data_str = base64.b85encode(data).decode()
#data_str_block = 5000
#f = open('backup_b64.txt','w')
#f.write(data_str)
#f.close()
###===###.\tob64_v2.py
import base64
import glob
#==SPACE==#

#==SPACE==#

py_files = glob.glob("./**/*.py", recursive=True)+glob.glob("./**/*.js", recursive=True)+glob.glob("./**/*.css", recursive=True)+glob.glob("./**/*.html", recursive=True)+glob.glob("./**/*.ini", recursive=True)+glob.glob("./**/*.svg", recursive=True)+glob.glob("./**/*.json", recursive=True)
#==SPACE==#

for p in py_files:
    print(p)
#==SPACE==#

total_strs = []
parts = 2
#==SPACE==#

for py_file in py_files:
    total_strs.append("\n###===###"+py_file+'\n')
    l = open(py_file, encoding='utf8').readlines()
    for line in l:
        if len(line.strip())==0:
            total_strs.append("#==SPACE==#\n")
        total_strs.append(line)
#==SPACE==#

lim = len(total_strs)//parts
#==SPACE==#

with open("backup_p1.txt",'w', encoding='utf-8') as f_out:
        for line in total_strs[:lim]:
            f_out.write(line)
#==SPACE==#

with open("backup_p2.txt",'w', encoding='utf-8') as f_out:
        for line in total_strs[lim:]:
            f_out.write(line)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#data = open("_backup.rar",'rb').read()
#data_str = base64.b85encode(data).decode()
#data_str_block = 5000
#f = open('backup_b64.txt','w')
#f.write(data_str)
#f.close()

###===###.\back01\main_server.py
#==SPACE==#

if __name__ == '__main__':
    import asyncio
    import multiprocessing as mp
    from multiprocessing import Process, Manager, freeze_support
    from threading import Thread
    import time
    import asyncio
    import websockets
    import json
    import time
    import secrets
#==SPACE==#

    mp.set_start_method('spawn')
    freeze_support()
#==SPACE==#

    from modules.sectorServer import EngineSector_interactor
    from modules.flaskApp import ServerInteractorFlaskApp
    from modules.network.WebsocketController import ConnectionController
#==SPACE==#
   
    ctx_manager = Manager()
    server = EngineSector_interactor()
    server.init_server(ctx_manager)
    server.start()
    #ConnectionController.server = server
    loop = asyncio.new_event_loop()
#==SPACE==#

    thread_async = Thread(target = loop.run_forever)
    asyncio.set_event_loop(loop)
#==SPACE==#

    loop.create_task(ConnectionController.main())
    loop.create_task(ConnectionController.broadcast())
    #loop.create_task(ConnectionController.clear_broken_connections())
    thread_async = Thread(target = loop.run_forever)
    thread_async.start()
#==SPACE==#

    flask_app = ServerInteractorFlaskApp()
    flask_app.run_forever()
#==SPACE==#

    print("server launched")
#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\test.py
from math import ceil
print(int(1.8))
print(int(1.1))
print(ceil(1.8))
print(ceil(1.1))

###===###.\back01\modules\flaskApp.py
import requests
from flask import Flask, jsonify, make_response, request
from flask_cors import CORS
#==SPACE==#

import json
#==SPACE==#

from modules.network.WebsocketController import ConnectionController
from modules.sectorServer import EngineSector_interactor
from modules.ship.projectile_blueprints import ProjectileConstructorController
from modules.physEngine.core import hBodyStatsCalculator
app = Flask(__name__)
cors = CORS(app)
ProjectileConstructorController()
#==SPACE==#

from modules.users_controller import UsersControler
UsersControler()
#==SPACE==#

from modules.utils import CommandLogger
from gevent.pywsgi import WSGIServer
import glob
import time
import random
#==SPACE==#

from flask import render_template
#==================================ADMIN========================================================================
@app.route('/', methods=["GET"])
def check_token():
    sleep_time = random.uniform(0, 1)
    time.sleep(sleep_time)
    return make_response(jsonify("helloworld, commander"), 200)
#==SPACE==#

#==SPACE==#

@app.route('/test_html', methods=["GET"])
def test_html():
    return render_template("index.html")
#==SPACE==#

#==SPACE==#

@app.route('/admin/maps', methods=["GET"])
def get_maps():
    map_list = glob.glob("maps/*.json")
    map_list_out = []
    for map in map_list:
        map_list_out.append(map.split('\\')[-1])
    return make_response(jsonify(map_list_out), 200)
#==SPACE==#

#==SPACE==#

@app.route('/admin/configs', methods=["GET"])
def get_config_list():
    file_list = glob.glob("configs/*.ini")
    file_list_out = []
    for filename in file_list:
        file_list_out.append(filename.split('\\')[-1])
    return make_response(jsonify(file_list_out), 200)
#==SPACE==#

import configparser
@app.route('/admin/configs/<filename>', methods=["GET"])
def get_config_content(filename):
#==SPACE==#

    config_data = configparser.ConfigParser()
    config_data.read("configs/"+filename)
    output_dict=dict()
    sections=config_data.sections()
    for section in sections:
        items=config_data.items(section)
        output_dict[section]=dict(items)
#==SPACE==#

    return make_response(jsonify(output_dict), 200)
#==SPACE==#

@app.route('/admin/connections', methods=["GET"])
def get_connections():
    return make_response(jsonify(ConnectionController.connection_ips), 200)
#==SPACE==#

@app.route('/utils/orbital_stats', methods=["GET"])
def orbital_stats():
    #body_descr = request.headers["body"]
    r = {}
    tmp = request.headers.get("Body-Description")
    body_descr = json.loads(tmp)
    try:
        stats = hBodyStatsCalculator.get_stats(body_descr)
    except Exception as e:
        stats = {}
    return make_response(jsonify(stats), 200)
#==SPACE==#

#==SPACE==#

@app.route('/utils/commands_stats', methods=["GET"])
def commands_stats():
    #body_descr = request.headers["body"]
    stats = CommandLogger().get_stats()
    return make_response(jsonify(stats), 200)
#==SPACE==#

#==================================USERS========================================================================
@app.route('/users/login', methods=["GET"])
def users_login():
    username = request.headers.get("Username")
    password = request.headers.get("Password")
    result = UsersControler().auth(username, password)
    if result:
        return make_response(jsonify(None), 200)
    return make_response(jsonify(None), 403)
#==SPACE==#

@app.route('/users/roles/list', methods=["GET"])
def users_role_list():
    username = request.headers.get("Username")
    result = UsersControler().get_roles_list(username)
    return make_response(jsonify(result), 200)
#==SPACE==#

@app.route('/users/roles/table', methods=["GET"])
def users_role_table():
    result = UsersControler().get_state()
    return make_response(jsonify(result), 200)
#==SPACE==#

@app.route('/users/roles/role', methods=["PUT"])
def users_set_role():
    username = request.headers.get("Username")
    role = request.headers.get("Role")
    state = request.headers.get("State")
    result = UsersControler().set_role(username, role, state)
    return make_response(jsonify(None), 200)
#==================================PROJECTILES========================================================================
@app.route("/projectile_constructor/<ship_id>/blueprints", methods=["GET"])
def ships_blueprints(ship_id):
    blueprints = EngineSector_interactor().get_blueprints(ship_id)
    return make_response(jsonify(blueprints), 200)
#==SPACE==#

#==SPACE==#

@app.route("/projectile_constructor/stats", methods=["GET"])
def get_blueprint_stats():
    blueprint = json.loads(request.headers["blueprint"])
    stats = ProjectileConstructorController().get_stats(blueprint)
    return make_response(jsonify(stats), 200)
#==SPACE==#

#==================================QUEST CONTROLLER========================================================================
@app.route("/quest_controller/get_state", methods=["GET"])
def quest_controller_get_state():
    quest_points_state = EngineSector_interactor().get_quest_point_state()
    return make_response(jsonify(quest_points_state), 200)
#==SPACE==#

#==============================MEDICINE=============================================================
@app.route('/med_states/<shipname>', methods=["GET"])
def get_med_states(shipname):
    med_data = EngineSector_interactor().get_med_states(shipname)
    if not med_data: return make_response("no data", 200)
    print(med_data)
    return render_template("medic.html", hospital = med_data["hospital"], roles = med_data["roles"])
#==SPACE==#

from modules.physEngine.world_constants import WorldPhysConstants
from modules.utils import ConfigLoader
import math
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

class ServerInteractorFlaskApp:
    def __init__(self):
        pass
#==SPACE==#

    def run_forever(self):
        http_server = WSGIServer(("0.0.0.0", 1924), app)
        http_server.serve_forever()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\modules\sectorServer.py
import multiprocessing as mp
import time
import asyncio
from random import randrange
from math import *
#==SPACE==#

from enum import Enum
#==SPACE==#

class SectorCommandType(Enum):
    MOVE="spawn"
    PREDICT_DEPTH = "prediction_depth"
    RESTART="restart"
    AIM = "aim"
    LAUNCH = "launch"
    SET_PHYSICS = "set_physics"
#==SPACE==#

#==SPACE==#

#обертка для процесса, в котором работает сервер.
#in_queue - очередь для команд: спавн, передвижение
#контекст менеджер передается из базового процесса и создается в __main__
#==SPACE==#

class EngineSector_interactor:
#==SPACE==#

    output_template = {
        "observer_id": None,
        "nav_data": {
            "observer_pos": [0,0],
            "hBodies": {},
            "lBodies": {},
        },
#==SPACE==#

        "state_data":None,
#==SPACE==#

        "performance":{
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        }
    }
#==SPACE==#

    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(EngineSector_interactor, cls).__new__(cls)
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def init_server(self, mp_ctx_manager):
        if mp_ctx_manager:
            self.server = None
            self.in_queue = mp.Queue()
            self.out_sector_data = mp_ctx_manager.dict()
            self.out_sector_data["server_is_alive"] = False
            self.out_sector_data["projectile_blueprints"] = {}
            self.out_sector_data["solar_flare"] = {}
            self.out_sector_data["medicine"] = {}
            self.out_sector_data["quest_points_controller"] = {}
            self.out_sector_data["map_border"] = 1000
#==SPACE==#

#==SPACE==#
                
#==SPACE==#

    def get_ships_list(self):
        list_ships = []
        tmp = self.out_sector_data["lBodies"]
        for t in tmp:
            if tmp[t][0] == "ae_ship":
                list_ships.append({
                    "id":t,
                })
        return list_ships
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_quest_point_state(self):
        return self.out_sector_data["quest_points_controller"]
#==SPACE==#

#==SPACE==#

    #============================КОМАНДЫ ДЛЯ CЕРВЕРА=============================================
#==SPACE==#

#==SPACE==#

    def proceed_command(self, command):
        self.in_queue.put(command)
#==SPACE==#

#==SPACE==#

#==SPACE==#

    #=============ИСХОДЯЩИЙ ПОТОК================================================================
#==SPACE==#

#==SPACE==#
    
#==SPACE==#

#==SPACE==#
            
    def get_sector_map(self, key = None):
        data = {}
        try:
            if self.out_sector_data["server_is_alive"] == False:
                return EngineSector_interactor.output_template
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
            if key!=None:
                data = self.out_sector_data[f"{key}_field_view"]
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
            else:
                data = self.out_sector_data["global_field_view"]
                data["ships_state"] = self.out_sector_data["ships_state"]
                data["stations_state"] = self.out_sector_data["stations_state"]
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
            data["performance"] = self.out_sector_data["performance"]
            data["systems_state"] = self.out_sector_data["systems_state"]
            data["solar_flare"] = self.out_sector_data["solar_flare"]
            data["medicine"] = self.out_sector_data["medicine"]
            data["map_border"] = self.out_sector_data["map_border"]
#==SPACE==#

        except Exception as e:
            return EngineSector_interactor.output_template
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
        return data
#==SPACE==#

#==SPACE==#
        
    def get_med_states(self, key):
        key_t = f"{key}_field_view"
        if key_t not in self.out_sector_data: return {}
        data = self.out_sector_data[key_t]
        med_data = data["state_data"]["med_sm"]
        return med_data
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_status(self):
        self.p.join(timeout=0)
        if self.p.is_alive():
            return {"EngineSector":"OK"}
#==SPACE==#

    def get_blueprints(self, mark_id):
        blueprints = self.out_sector_data["projectile_blueprints"]
        if mark_id in blueprints:
            return blueprints[mark_id]
        return {}
#==SPACE==#

    #=============================================================================================
    def start(self):
        self.p = mp.Process(target=self.run_instance, args=(self.in_queue,self.out_sector_data,))
        self.p.start()
#==SPACE==#

    def run_instance(self, in_queue, out_sector_data):
        instance = EngineSector(in_queue, out_sector_data)
        instance.start()
#==SPACE==#

#==SPACE==#

from modules.physEngine.core import hBodyPool_Singleton
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.core import CrossDistancePool
from modules.physEngine.predictor import launch_new_TrajectoryPredictor_controller, TrajectoryPredictor_controller
from modules.physEngine.active_objects import ae_Ship
from modules.physEngine.triggers.collector import TriggerQueue
from modules.physEngine.triggers.handler import TriggerHandler
from modules.physEngine.world_constants import WorldPhysConstants
from modules.ship.ship import ShipPool_Singleton
from modules.map_controllers.loader import MapLoader
from modules.map_controllers.editor import MapEditor
from modules.utils import ConfigLoader
from datetime import datetime
import traceback
from modules.utils import Command, catch_exception,get_dt_ms,PerformanceCollector
from sys import getsizeof
from random import randint
from modules.ship.projectile_blueprints import ProjectileConstructorController
from modules.physEngine.solar_flare.solar_flar_activator import SolarFlareActivator
from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
from modules.physEngine.quests.quest_controller import QuestPointsController
import numpy as np
#==SPACE==#

class EngineSector:
    @catch_exception
    def __init__(self, in_queue:mp.Queue, out_sector_data):     
        self.in_queue = in_queue
        self.out_sector_data = out_sector_data
        #представление
        self.hBodies = hBodyPool_Singleton()#статичные астероиды.
                                            #Хранятся в синглетоне
#==SPACE==#

        self.lBodies:lBodyPool_Singleton = lBodyPool_Singleton()
#==SPACE==#

        #cShips for ControlledShips
        self.cShips = ShipPool_Singleton()
#==SPACE==#

        self.triggerHandler = TriggerHandler()
#==SPACE==#

        self.distancePool = CrossDistancePool()
        self.solarFlareActivator = SolarFlareActivator()
        self.quest_points_controller = QuestPointsController()
#==SPACE==#

        self.trajectoryPredictor_controller = TrajectoryPredictor_controller()
#==SPACE==#

        self.map_loader = MapLoader()
        self.map_editor = MapEditor()
        launch_new_TrajectoryPredictor_controller()
        #инициализация
        self.map_loader.load_map()
        #self.map_loader.load_ships()
#==SPACE==#

        self.event_loop = asyncio.new_event_loop()
        self.event_loop.create_task(self.read_input_data())
        self.event_loop.create_task(self.update_bodies())
        self.event_loop.create_task(self.update_quest_poits_state())
        self.event_loop.create_task(self.update_ships_state())
        self.event_loop.create_task(self.update_station_state())
        #self.event_loop.create_task(self.map_autosaver())
        self.global_field_view = {
                                    "observer_id": None,
                                    "nav_data": {
                                        "observer_id": None,
                                        "observer_pos": [0,0],
                                        "hBodies": self.hBodies.get_bodies_description(),
                                        "lBodies": self.lBodies.get_bodies_description(),
#==SPACE==#

#==SPACE==#

#==SPACE==#
                                            
                                    },
                                }
#==SPACE==#

        self.out_sector_data["global_field_view"] = self.global_field_view     
        self.simulation_is_runned = True
#==SPACE==#
 
    def start(self):
        self.event_loop.run_forever()
#==SPACE==#

    #===========================РАЗДЕЛ ДЛЯ КОРУТИН В ЦИКЛЕ ДВИЖКА СЕКТОРА============================================
#==SPACE==#

    """command = {
        "level":"ship", "server",
        "target_id": "id",
        "command": "aim"
        "params": {
#==SPACE==#

        }
    }"""
#==SPACE==#

    async def read_input_data(self):
        while True:
            await asyncio.sleep(0.02)
            while not self.in_queue.empty():
                command = Command(self.in_queue.get())
                self.proceed_command(command)
#==SPACE==#

    def proceed_command(self, command:Command):
        try:
            if command.contains_level("predictor"):
                launch_new_TrajectoryPredictor_controller()
                #self.trajectoryPredictor_controller.proceed_command(command)
            if command.contains_level("server"):
                self.proceed_server_command(command)
            elif command.contains_level("ship"):
                self.cShips.proceed_command(command)
            elif command.contains_level("map_editor"):
                self.map_editor.proceed_command(command)
            elif command.contains_level("map_loader"):
                self.map_loader.proceed_command(command)
                self.out_sector_data["map_border"] = self.hBodies.get_max_distance()
            elif command.contains_level("solar_flare"):
                self.solarFlareActivator.proceed_command(command)
            elif command.contains_level("config_loader"):
                ConfigLoader().proceed_command(command)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
            elif command.contains_level("hBodiesPool"):
                self.hBodies.proceed_command(command)
            elif command.contains_level("medicine"):
                self.medicineController.proceed_command(command)
            elif command.contains_level("qp_controller"):
                QuestPointsController().proceed_command(command)
#==SPACE==#

            elif command.contains_level("station_controller"):
                self.proceed_station_command(command)
#==SPACE==#

        except Exception as e:
            print("SectorServer Command Execution",repr(e))
#==SPACE==#

#==SPACE==#

    def proceed_station_command(self, command:Command):
        try:
            action = command.get_action()
            params = command.get_params()
            target = params["target"]
            if action == "activate_station_defence":
                if target in self.lBodies.bodies:
                    self.lBodies[target].activate_station_defence()
            if action == "destroy_station":
                if target in self.lBodies.bodies:
                    self.lBodies[target].self_destroy()
            if action == "set_map_border":
                self.out_sector_data["map_border"] = params["value"]
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        except Exception as e:
            print("SectorServer",repr(e))
#==SPACE==#

    def proceed_server_command(self, command:Command):
        try:
            action = command.get_action()
            params = command.get_params()
            if action == SectorCommandType.SET_PHYSICS:
                WorldPhysConstants().set_Gconst(command["Gconst"])
                WorldPhysConstants().set_timestep(command["timestep"])
                TrajectoryPredictor_controller().set_physics(command)
            if action == "restart":
                self.map_loader.load_map()
                self.map_loader.load_ships()
            if action == "pause":
                self.simulation_is_runned = False
            if action == "run":
                self.simulation_is_runned = True
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        except Exception as e:
            print("SectorServer",repr(e))
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
    #==========ФИЗИКА===============================================================================================
#==SPACE==#

    async def update_bodies(self):
        t1 = datetime.now()
        desiredFPS = 30
        time_interval = 1/desiredFPS
        self.out_sector_data["server_is_alive"] = True
        while True:
            try:
                dt = datetime.now() - t1
                t1 = datetime.now()
#==SPACE==#

                if self.simulation_is_runned:
                    tmp_t0= datetime.now()
                    self.distancePool.update()
                    tmp_t1= datetime.now()
                    self.lBodies.iter_loop() #обработка движения
                    tmp_t2 = datetime.now()
                    self.hBodies.iter_loop() #обработка активности станций
                    tmp_t3 = datetime.now()
                    self.triggerHandler.proceed_triggers_list() #обработка активированных триггеров
                    tmp_t4 = datetime.now()
                    self.cShips.next_step() #шаг расчёта для систем кораблей
                    tmp_t5 = datetime.now()
                    self.solarFlareActivator.step()
#==SPACE==#

                #обновления админского поля зрения
                tmp_t6 = datetime.now()
                self.global_field_view["nav_data"]["hBodies"] = self.hBodies.get_bodies_description()
                tmp_t7 = datetime.now()
                self.global_field_view["nav_data"]["lBodies"] = self.lBodies.get_bodies_description()
                self.global_field_view["nav_data"]["visible_ships"] = EntityIDGroupsController().get("id_labels_detectable")
                tmp_t8 = datetime.now()
                self.out_sector_data["global_field_view"] = self.global_field_view
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
                #обновления поля зрения для каждого корабля
                tmp_t9 = datetime.now()
#==SPACE==#

#==SPACE==#
                    
                for ae_ship_id in self.cShips.ships:
                    field_view = self.cShips.ships[ae_ship_id].get_viewfield()
                    self.out_sector_data[f"{ae_ship_id}_field_view"] = field_view
                tmp_t10 = datetime.now()
#==SPACE==#

#==SPACE==#

#==SPACE==#

                #оценка производительности
                dt = datetime.now() - t1
                calculation_time = dt.microseconds/1000000
                delay_time = max(0,time_interval-calculation_time)
                #self.out_sector_data["time2processFrame"] = dt.microseconds/1000
#==SPACE==#

#==SPACE==#

                performance_p1 = {
                                                        "predictors_step_time": TrajectoryPredictor_controller().get_predictor_performance_statistics(),
                                                        "real_calculation_time":calculation_time,
                                                        "free_awaiting_time": time_interval-calculation_time,
                                                        "frame_size[bytes]": get_size(self.global_field_view),
                                                        "distancePool_time": get_dt_ms(tmp_t0, tmp_t1),
                                                        "lbodies_time": get_dt_ms(tmp_t1, tmp_t2),
                                                        "hbodies_time": get_dt_ms(tmp_t2, tmp_t3),
                                                        "trigger_time": get_dt_ms(tmp_t3, tmp_t4),
                                                        "cships_time": get_dt_ms(tmp_t4, tmp_t5),
                                                        #"admin_view": get_dt_ms(tmp_t6, tmp_t8),
                                                        "ships_view": get_dt_ms(tmp_t9, tmp_t10),
#==SPACE==#

#==SPACE==#

#==SPACE==#
                                                            
                                                        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
                performanse_p2 = PerformanceCollector().get()
#==SPACE==#

                performanse = dict(performance_p1, **performanse_p2)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
#==SPACE==#

                self.out_sector_data["performance"] = performanse
#==SPACE==#

                PerformanceCollector().clear()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
                self.out_sector_data["systems_state"] = {
                    "map_locked":str(not self.hBodies.realtime_update)
                }
                self.out_sector_data["solar_flare"] = self.solarFlareActivator.get_status()
                self.out_sector_data["projectile_blueprints"] = ProjectileConstructorController().blueprints
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
                self.map_border_check_trigger()
                WorldPhysConstants().next_step()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
                await asyncio.sleep(delay_time)
            except Exception as e:
                print(e)
                print(traceback.format_exc())
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def map_border_check_trigger(self):
        for ship_id in self.cShips.ships:
            pos = self.lBodies[ship_id].get_position_np()
            distance2ship = np.linalg.norm(pos)
            if distance2ship>self.out_sector_data["map_border"]:
                new_speed = -pos/distance2ship
                self.lBodies[ship_id].set_velocity(new_speed)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
    
#==SPACE==#

    #===============================================================================================================
#==SPACE==#

    async def update_ships_state(self):
        while True:
            await asyncio.sleep(1)
            ships_stats = {}
            for ae_ship_id in self.cShips.ships:
                ships_stats[ae_ship_id] = self.cShips.ships[ae_ship_id].get_short_description()
            self.out_sector_data["ships_state"] = ships_stats
#==SPACE==#

    async def update_station_state(self):
        while True:
            try:
                await asyncio.sleep(1)
                stations_stats = {}
                for station_idx in EntityIDGroupsController().get("is_station"):
                    stations_stats[station_idx] = self.lBodies[station_idx].get_short_description()
                self.out_sector_data["stations_state"] = stations_stats
            except Exception as e:
                print("update_station_state",repr(e))
#==SPACE==#

#==SPACE==#

    async def update_quest_poits_state(self):
        while True:
            await asyncio.sleep(1)
            self.out_sector_data["quest_points_controller"] = self.quest_points_controller.get_state()
#==SPACE==#

#==SPACE==#

    async def map_autosaver(self):
        cnter = 0
        while True:
            await asyncio.sleep(60*1)
            self.map_editor.save_map(f"auto_save_#{cnter}")
            self.map_editor.save_map(f"auto_save_latest")
            cnter=cnter+1
            if cnter>9:
                cnter=0
#==SPACE==#

#==SPACE==#
    
#==SPACE==#

import sys
def get_size(obj, seen=None):
    """Recursively finds size of objects"""
    size = sys.getsizeof(obj)
    if seen is None:
        seen = set()
    obj_id = id(obj)
    if obj_id in seen:
        return 0
    # Important mark as seen *before* entering recursion to gracefully handle
    # self-referential objects
    seen.add(obj_id)
    if isinstance(obj, dict):
        size += sum([get_size(v, seen) for v in obj.values()])
        size += sum([get_size(k, seen) for k in obj.keys()])
    elif hasattr(obj, '__dict__'):
        size += get_size(obj.__dict__, seen)
    elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes, bytearray)):
        size += sum([get_size(i, seen) for i in obj])
    return size
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#


###===###.\back01\modules\users_controller.py
#==SPACE==#

class UserData:
    def __init__(self, username):
        self.username = username
        self.roles = {"map_editor": False, "admin":False, "game_master": False, "pilot": False, "captain":False,
                        "navigator":False, "cannoneer":False, "engineer":False, "NPC_pilot":False, "medic": False, "common_radar":False}
#==SPACE==#

    def get_roles(self):
        return self.roles
#==SPACE==#

#==SPACE==#

    def set_role(self, role, state):
        if type(state) != bool:
            state = state.lower()=="true"
        self.roles[role] = state
#==SPACE==#

    def auth(self, password):
        return True
#==SPACE==#

#==SPACE==#

class UsersControler:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(UsersControler, cls).__new__(cls)
            cls._instance.users = {}
            for username in ["captain", "navigator", "cannoneer", "engineer", "medic"]:
                cls._instance.users[username] = UserData(username)
                for role in ["map_editor", "admin", "game_master", "pilot", "captain", "navigator", "cannoneer", "engineer", "medic", "NPC_pilot"]:
                    cls._instance.users[username].set_role(role, role==username)
#==SPACE==#

            for username in ["admin", "master_medic", "NPC_pilot"]:
                cls._instance.users[username] = UserData(username)
                for role in ["map_editor", "admin", "game_master", "pilot", "captain", "navigator", "cannoneer", "engineer", "medic", "NPC_pilot", "common_radar"]:
                    cls._instance.users[username].set_role(role, True)
#==SPACE==#

            for username in ['common_radar']:
                cls._instance.users[username] = UserData(username)
                for role in ["common_radar"]:
                    cls._instance.users[username].set_role(role, True)
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def auth(self, username, password):
        if username not in self.users:
            return False
        return self.users[username].auth(password)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_state(self):
        result = {}
        for username in self.users:
            result[username] = self.users[username].get_roles()
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_roles_list(self, username):
        result = []
        roles_dict = self.users[username].get_roles()
        for role in roles_dict:
            if roles_dict[role]:
                result.append(role)
#==SPACE==#

        return result
#==SPACE==#

#==SPACE==#

    def set_role(self, username, role, state):
        self.users[username].set_role(role, state)

###===###.\back01\modules\utils.py
#==SPACE==#

#==SPACE==#

#==SPACE==#

from queue import Queue
class Command:
    def __init__(self, command_json):
        self.json = command_json
#==SPACE==#

    def contains_level(self, level_keyword):
        return level_keyword in self.json["level"]
#==SPACE==#

    def get_target_id(self, level_keyword):
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        levels = self.json["level"].split('.')
        targets = self.json["target_id"].split('.')
        for i,level_name in enumerate(levels):
            if level_name==level_keyword:
                return targets[i]
        return None
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_params(self):
        return self.json["params"]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_action(self):
        return self.json["action"]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
class CommandQueue:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(CommandQueue, cls).__new__(cls)
            cls._instance.cmd_queue = Queue()
#==SPACE==#

        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def add_command(self, cmd:Command):
        self.cmd_queue.put(cmd)
#==SPACE==#

    def is_empty(self):
        return self.cmd_queue.empty()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_next(self):
        return self.cmd_queue.get()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
import traceback
import functools
#==SPACE==#

def catch_exception(function):
    from functools import wraps
    @functools.wraps(function)
    def wrapper(*args, **kw):
            try:
                result = function(*args, **kw)
                return result
            except Exception as e:
                print("======catch_exception============")
                print(traceback.format_exc())
                print(repr(e))
    return wrapper
#==SPACE==#

def get_dt_ms(t1, t2):
    return round((t2-t1).microseconds/1000000,4)
#==SPACE==#

import configparser
#==SPACE==#

#==SPACE==#

class ConfigLoader:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(ConfigLoader, cls).__new__(cls)
            cls._instance.config = configparser.ConfigParser()
            cls._instance.filename = "configs/config.ini"
            cls._instance.config.read("configs/config.ini")
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def update(self):
        self.config = configparser.ConfigParser()
        self.config.read(self.filename)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get(self, param_string, type = str):
        tmp = self.config
        for key in param_string.split('.'):
            tmp = tmp[key]
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        if type==list:
            return [float(a) for a in tmp.split()]
        return type(tmp)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def proceed_command(self, command:Command):
        params = command.get_params()
        action = command.get_action()
        match action:
            case "save":
                self.save(params["filename"], params["config_data"])
            case "load":
                self.load(params["filename"])
#==SPACE==#

    def load(self, filename):
        self.filename = f"configs/{filename}"
        self.update()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def save(self, filename, config_data):
        config_object = configparser.ConfigParser()
        sections=config_data.keys()
        for section in sections:
            config_object.add_section(section)
        for section in sections:
            inner_dict=config_data[section]
            fields=inner_dict.keys()
            for field in fields:
                value=inner_dict[field]
                config_object.set(section, field, str(value))
#==SPACE==#

        file = open("configs/"+filename+".ini","w")
        config_object.write(file)
        file.close()
        #self.config = configparser.ConfigParser()
        #self.config.read(f"configs/{filename}")
#==SPACE==#

#==SPACE==#

#==SPACE==#

class PerformanceCollector:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(PerformanceCollector, cls).__new__(cls)
            cls._instance.data = {}
#==SPACE==#

        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def add(self, key, timestep):
        if key not in self.data: self.data[key]=0
        self.data[key] = self.data[key]+timestep
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get(self):
        return self.data
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def clear(self):
        for k in self.data:
            self.data[k]=0
#==SPACE==#

#==SPACE==#

#==SPACE==#

class CommandLogger:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(CommandLogger, cls).__new__(cls)
#==SPACE==#

            cls._instance.commands = []
            cls._instance.commands_stats = {}
#==SPACE==#

        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def add(self, cmd:Command):
        action = cmd.get_action()
        if action not in self.commands_stats:
            self.commands_stats[action] = 0
        self.commands_stats[action] = self.commands_stats[action] + 1
        self.commands.append(cmd.json)
#==SPACE==#

    def get_stats(self):
        return {
            "stats":self.commands_stats,
            "last_cmds": self.commands[-20:]
        }

###===###.\back01\modules\map_controllers\editor.py
#==SPACE==#

from modules.physEngine.core import hBody, CalculationUtilites
from modules.physEngine.active_objects import QuantumShadow, SpaceStation
from modules.physEngine.hb_entities import ResourceAsteroid, WormHole
from modules.physEngine.interactable_objects.container import intact_Container, ShipDebris, SpaceStationDebris
from modules.physEngine.projectiles.mine import pjtl_Mine
from modules.physEngine.projectiles.mine_master import Mine_type1, Mine_type2
from modules.ship.ship import Ship, NPC_Ship, NPC_Kraken
from modules.ship.shipPool import ShipPool_Singleton
from modules.utils import ConfigLoader,Command
from modules.physEngine.core import lBodyPool_Singleton, hBodyPool_Singleton
from modules.physEngine.predictor import TrajectoryPredictor_controller
from modules.physEngine.zones.meteors_zone import MeteorsCloud
import numpy as np
from random import randint
import json
import random
import copy
#==SPACE==#

class MapEditor:
    def __init__(self):
        self.hBodies = hBodyPool_Singleton()
        self.cShips = ShipPool_Singleton()
        self.lBodies = lBodyPool_Singleton()
        self.grid_step = ConfigLoader().get("world.map_step", float)
        self.selected_body_id = None
        self.spawner = EntitySpawner()
#==SPACE==#

        self.spawn_positions = {
#==SPACE==#

        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    #related commands: "create_hbody", "select_hbody",
    #     "create_lbody", "select_lbody",
    #     "unselect", cursor_move",
    #     "save",
    def proceed_command(self, command:Command):
        try:
            action = command.get_action()
            match action:
                case "brush_cache": self.brush_cache(command.get_params())
                case "brush_uncache": self.brush_uncache(command.get_params())
                case "brush_create": self.brush_create(command.get_params())
                case "brush_delete": self.brush_delete(command.get_params())
                case "brush_spawn_obstacles": self.brush_spawn_obstacles(command.get_params())
                case "brush_delete_obstacles": self.brush_delete_obstacles(command.get_params())
                case "brush_select_body": self.brush_select_body(command.get_params())
                case "select_body": self.select_body(command.get_params()["mark_id"])
                case "cursor_move": self.cursor_move(command.get_params()["position"], command.get_params()["clockwise"])
                case 'change_body': self.change_body(command.get_params()["descr"]["mark_id"], command.get_params()["descr"], command.get_params()["forced"])
                case 'spawn_body': self.spawn_body(command.get_params()["entity_type"],command.get_params())
                case 'copy_body': self.copy_body(command.get_params()["mark_id"])
                case 'delete_body': self.delete_body(command.get_params()["mark_id"])
                case 'save_map': self.save_map(command.get_params()["map_name"])
        except Exception as e:
            print(repr(e))
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

    def brush_select_body(self, brush_params):
        if self.selected_body_id:
            self.select_body(None)
            return
        brush_radius = brush_params["radius"]
#==SPACE==#

#==SPACE==#
            
        brush_position = brush_params["position"]
        brush_position_np = np.array([brush_position[0],brush_position[1]])
#==SPACE==#

        selected_idx = None
        distance = 9000000000000000000000000000000
        for body_idx in self.brush_get_hbodies2proceed(brush_params):
            distance2body = self.hBodies.bodies[body_idx].get_distance2position(brush_position_np)
            if distance2body<distance:
                distance = distance2body
                selected_idx = body_idx
        if not selected_idx:
            return
        self.select_body(selected_idx)
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

    def brush_get_hbodies2proceed(self, brush_params):
        brush_radius = brush_params["radius"]
#==SPACE==#

#==SPACE==#
            
        brush_position = brush_params["position"]
        brush_position_np = np.array([brush_position[0],brush_position[1]])
#==SPACE==#

        body_idx_to_proceed = []
        for body_idx in self.hBodies.bodies:
            if self.hBodies.bodies[body_idx].get_distance2position(brush_position_np)<brush_radius:
                body_idx_to_proceed.append(body_idx)
        return body_idx_to_proceed
#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def brush_get_lbodies2proceed(self, brush_params):
        brush_radius = brush_params["radius"]
#==SPACE==#

#==SPACE==#
            
        brush_position = brush_params["position"]
        brush_position_np = np.array([brush_position[0],brush_position[1]])
#==SPACE==#

        body_idx_to_proceed = []
        for body_idx in self.lBodies.bodies:
            if self.lBodies.bodies[body_idx].get_distance2position(brush_position_np)<brush_radius:
                body_idx_to_proceed.append(body_idx)
        return body_idx_to_proceed
#==SPACE==#

#==SPACE==#

    def brush_cache(self, brush_params):
        bodies = self.brush_get_hbodies2proceed(brush_params)
        for body_idx in bodies:
            self.hBodies.bodies[body_idx].cache_static_lbodies(True)
#==SPACE==#

#==SPACE==#

    def brush_uncache(self, brush_params):
        bodies = self.brush_get_hbodies2proceed(brush_params)
        for body_idx in bodies:
            self.hBodies.bodies[body_idx].uncache_static_lbodies(True)
#==SPACE==#

    def brush_create(self, brush_params):
        brush_position = brush_params["position"]
        brush_position_np = np.array([brush_position[0],brush_position[1]])
#==SPACE==#

        #получить точку, до границы которой ближе всего
        body_idx_to_start = None
        distance2brush_position = 99999999999
        for body_idx in self.hBodies.bodies:
            tmp_distance = self.hBodies.bodies[body_idx].get_distance2position_from_border(brush_position_np)
            if tmp_distance<distance2brush_position:
                body_idx_to_start = body_idx
                distance2brush_position = tmp_distance
#==SPACE==#

        #запустить генерацию
        new_radius = random.randint(brush_params["min_size"], brush_params["max_size"])
        new_mass = random.randint(brush_params["min_weight"], brush_params["max_weight"])
        cnter = 0
        while (not (self.brush_check_condition(body_idx_to_start, brush_position_np))) and (cnter<20):
#==SPACE==#

#==SPACE==#
                
            success, body_idx_to_start = self.brush_create_next(body_idx_to_start, brush_position_np, new_radius, new_mass)
            if success:
                if brush_params["closer"]:
                    new_radius = brush_params["max_size"]
                else:
                    new_radius = random.randint(brush_params["min_size"], brush_params["max_size"])
                new_mass = random.randint(brush_params["min_weight"], brush_params["max_weight"])
                cnter = cnter+1
            else:
                new_radius = new_radius*0.75
                if new_radius<brush_params["min_size"]:
                    return
#==SPACE==#

    def brush_check_condition(self, last_created_body_idx, brush_position):
        return self.hBodies.bodies[last_created_body_idx].is_position_in_gravity_well(brush_position)
#==SPACE==#

    def brush_create_next(self, ancor_body_idx, brush_position_np, new_radius, new_mass):
        #получаем всех соседей
#==SPACE==#

#==SPACE==#
            
        neighbours = self.hBodies.get_index_assosiated_idx_list(ancor_body_idx)
        neighbours.remove(ancor_body_idx)
#==SPACE==#

        #считаем все возможные точки пересечения, для каждой находим расстояние до кисти
        possible_points = []
        pos1 = self.hBodies[ancor_body_idx].get_position_np()
        rad1 = self.hBodies[ancor_body_idx].gravity_well_radius+new_radius+2
        for neigh_body_idx in neighbours:
            pos2 = self.hBodies[neigh_body_idx].get_position_np()
            rad2 = self.hBodies[neigh_body_idx].gravity_well_radius+new_radius+2
            points = CalculationUtilites.get_intersection_for_2_circles(pos1,rad1, pos2,rad2)
            if points:
                for point in points:
                    distance2brush = np.linalg.norm(point - brush_position_np)
                    possible_points.append((point, distance2brush))
#==SPACE==#

        #отсортировать по удалению от кисти
        possible_points = sorted(possible_points, key=lambda point: point[1])
#==SPACE==#

        #для каждой потенциальной позиции чекаем проверку на пересечения с другими телами
        for point in possible_points:
            if self.brush_body_can_be_placed(point[0],new_radius):
                new_hbody = hBody(point[0][0], point[0][1], new_radius, new_mass)
                self.hBodies.add(new_hbody)
                return True, new_hbody.mark_id
        return False, ancor_body_idx
#==SPACE==#

    def brush_body_can_be_placed(self, position, new_radius):
        for body_idx in self.hBodies.bodies:
            tmp_distance = self.hBodies.bodies[body_idx].get_distance2position_from_border(position)
            if tmp_distance<=new_radius:
                return False
        return True
#==SPACE==#

    def brush_delete(self, brush_params):
        body_idx_to_del = self.brush_get_hbodies2proceed(brush_params)
        for body_idx in body_idx_to_del:
            self.hBodies.delete(body_idx)
#==SPACE==#

    def copy_body(self, mark_usi):
        body = self.hBodies[mark_usi]
        body_descr = body.get_description()
        body_descr["mark_id"] = None
        mark_id = self.spawner.spawn(body_descr["type"], body_descr)
        self.select_body(mark_id)
        self.hBodies[mark_id].put_description(body_descr)
#==SPACE==#

    def brush_spawn_obstacles(self, brush_params):
        body_idx_to_proceed = self.brush_get_hbodies2proceed(brush_params)
#==SPACE==#

        obstacles_min_count = brush_params["obstacles_min_count"]
        obstacles_max_count = brush_params["obstacles_max_count"]
        obstacles_probability = brush_params["obstacles_probability"] #(from 0 to 100)
        obstacles_type = brush_params["obstacles_type"]
        for body_idx in body_idx_to_proceed:
            random_chance = random.randint(0,100)
            if random_chance<obstacles_probability:
                obstacles_count = random.randint(obstacles_min_count, obstacles_max_count)
                self.brush_spawn_obstacles_to_hbody(body_idx, obstacles_count, obstacles_type)
#==SPACE==#

#==SPACE==#
        
    def brush_spawn_obstacles_to_hbody(self, hbody_idx, obstacles_count, obstacles_type):
        for i in range(obstacles_count):
            radius = random.randint(50, int(self.hBodies[hbody_idx].gravity_well_radius*0.9))
            distance = np.array([radius,0])
            angle = random.randint(0,360)
            position = self.hBodies[hbody_idx].get_position_np()+CalculationUtilites.rotate_vector(distance, angle)
            obstacle_body = None
            if obstacles_type == "Mine_type1/Mine_type2":
                obstacles_type = random.choice(obstacles_type.split('/'))
#==SPACE==#

            if obstacles_type == "MeteorsCloud":
                obstacle_body = MeteorsCloud(position[0],position[1])
#==SPACE==#

            if obstacles_type == "Mine_type1":
                obstacle_body = Mine_type1(position[0],position[1])
                obstacle_body.set_position_np_manual(position,random.choice([True, False]))
#==SPACE==#

            if obstacles_type == "Mine_type2":
                obstacle_body = Mine_type2(position[0],position[1])
                obstacle_body.set_position_np_manual(position,random.choice([True, False]))
            self.lBodies.add(obstacle_body)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def brush_delete_obstacles(self, brush_params):
        bodies = self.brush_get_lbodies2proceed(brush_params)
        for body_idx in bodies:
            lBodyPool_Singleton().delete(body_idx)
#==SPACE==#

#==SPACE==#

    #def brush_delete_obstacle(self, brush_params):
    #   pass
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def spawn_body(self, entity_type, entity_params):
        mark_id = self.spawner.spawn(entity_type, entity_params)
        self.select_body(mark_id)
#==SPACE==#

    def delete_body(self, mark_id):
        self.cShips.delete(mark_id)
        self.lBodies.delete(mark_id)
        self.hBodies.delete(mark_id)
#==SPACE==#

    def get_related_body_pool(self, mark_id):
        bodies = self.lBodies
        if mark_id in self.hBodies.bodies: bodies = self.hBodies
        return bodies
#==SPACE==#

    def select_body(self, mark_id):
        if not mark_id: #т.е. unselect
            selected_ship = self.cShips.get(self.selected_body_id)
            if selected_ship:
                selected_ship_state = selected_ship.get_viewfield()["state_data"]
                selected_ship_position = self.lBodies.get(self.selected_body_id).get_description()["pos"]
#==SPACE==#

                selected_ship_description = {
                    "type": str(selected_ship.__class__.__name__),
                    "state":selected_ship_state,
                    "pos":selected_ship_position
                }
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
                self.spawn_positions[self.selected_body_id] = selected_ship_description
            selected_body = self.hBodies.get(self.selected_body_id)
            if selected_body:
                TrajectoryPredictor_controller().update_hbodies_location()
                self.hBodies.generate_index_for_single_body(self.selected_body_id)
        self.selected_body_id = mark_id
#==SPACE==#

    def change_body(self, mark_id, new_description, forced):
        bodies = self.get_related_body_pool(mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        bodies[mark_id].put_description(new_description, forced)
#==SPACE==#

    def cursor_move(self, position, clockwise):
        if self.selected_body_id:
            bodies = self.get_related_body_pool(self.selected_body_id)
            bodies.bodies[self.selected_body_id].set_position_np_manual(np.array(position),clockwise)
        pass
#==SPACE==#

    def save_map(self, map_name):
        self.hBodies.uncache_static_lbodies()
        hbodies_description = self.hBodies.get_bodies_description()
        self.lBodies.update_description()
        lbodies_description = self.lBodies.get_bodies_description()
        ships_description = self.cShips.get_ships_description()
        sector_map = {
            "hBodies":hbodies_description,
            "lBodies": lbodies_description,
            "cShips":ships_description,
        }
        json.dump(sector_map, open(f"maps/{map_name}.json", 'w'))
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

class EntitySpawner:
    def __init__(self):
        self.hBodies = hBodyPool_Singleton()
        self.cShips = ShipPool_Singleton()
        self.lBodies = lBodyPool_Singleton()
        pass
#==SPACE==#

    def spawn(self, entity_type, entity_params):
        spawn_position = 999999
        mark_id = entity_params["mark_id"] if entity_params["mark_id"] else str(randint(0,10000000))
        match entity_type:
            case "ae_Ship":
                mark_id = "aeShip_"+str(randint(0,10000000))
                if "Sirocco" not in self.lBodies.bodies:
                    mark_id = "Sirocco"
                ship1 = Ship(spawn_position,spawn_position, mark_id=mark_id)
                mark_id = ship1.mark_id
                self.cShips.spawn(ship1)
            case 'NPC_Ship':
                if not mark_id: mark_id = "aeShip_"+str(randint(0,10000000))
                ship1 = NPC_Ship(spawn_position,spawn_position, mark_id=mark_id)
                mark_id = ship1.mark_id
                self.cShips.spawn(ship1)
#==SPACE==#

            case 'NPC_Kraken':
                mark_id = 'NPC_Kraken'
                ship1 = NPC_Kraken(spawn_position,spawn_position, mark_id=mark_id)
                mark_id = ship1.mark_id
                self.cShips.spawn(ship1)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
            case 'hBody':
                body = hBody(spawn_position, spawn_position,ConfigLoader().get("world.map_step", float))
                body.mark_id = mark_id
                self.hBodies.add(body)
            case 'ResourceAsteroid':
                body = ResourceAsteroid(spawn_position, spawn_position,ConfigLoader().get("world.map_step", float))
                body.mark_id = mark_id
                self.hBodies.add(body)
            case "pjtl_Mine":
                body = pjtl_Mine("admin")
                mark_id = body.mark_id
                self.lBodies.add(body)
            case 'intact_Container':
                body = intact_Container(-9000, 9000)
                mark_id = body.mark_id
                self.lBodies.add(body)
            case 'WormHole':
                body = WormHole(spawn_position, spawn_position,ConfigLoader().get("world.map_step", float))
                mark_id = body.mark_id
                self.hBodies.add(body)
            case "ShipDebris":
                body = ShipDebris(spawn_position, spawn_position,mark_id)
                mark_id = body.mark_id
                self.lBodies.add(body)
#==SPACE==#

            case 'MeteorsCloud':
                body = MeteorsCloud(spawn_position, spawn_position)
                mark_id = body.mark_id
                self.lBodies.add(body)
#==SPACE==#

            case 'QuantumShadow':
                body = QuantumShadow(spawn_position, spawn_position)
                mark_id = body.mark_id
                self.lBodies.add(body)
#==SPACE==#

            case 'SpaceStation':
                body = SpaceStation(spawn_position, spawn_position, mark_id)
                mark_id = body.mark_id
                self.lBodies.add(body)
#==SPACE==#

            case 'SpaceStationDebris':
                body = SpaceStationDebris(spawn_position, spawn_position, mark_id)
                mark_id = body.mark_id
                self.lBodies.add(body)
#==SPACE==#

            case 'Mine_type1':
                body = Mine_type1(spawn_position, spawn_position)
                mark_id = body.mark_id
                self.lBodies.add(body)
#==SPACE==#

            case 'Mine_type2':
                body = Mine_type2(spawn_position, spawn_position)
                mark_id = body.mark_id
                self.lBodies.add(body)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
        return mark_id
#==SPACE==#


###===###.\back01\modules\map_controllers\loader.py
#==SPACE==#

#from modules.physEngine.core import hBodyPool_Singleton
from modules.physEngine.core import hBody, lBodyPool_Singleton, hBodyPool_Singleton
from modules.physEngine.hb_entities import ResourceAsteroid, WormHole
from modules.physEngine.interactable_objects.container import intact_Container,ShipDebris
from modules.physEngine.active_objects import QuantumShadow, SpaceStation
from modules.physEngine.hb_entities import ResourceAsteroid, WormHole
from modules.physEngine.interactable_objects.container import intact_Container, ShipDebris, SpaceStationDebris
from modules.ship.ship import Ship, NPC_Ship
from modules.ship.shipPool import ShipPool_Singleton
from random import randint
from modules.utils import ConfigLoader,Command
from modules.physEngine.predictor import TrajectoryPredictor_controller
#from modules.physEngine.core import lBodyPool_Singleton
import json
from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
import traceback
from modules.physEngine.zones.meteors_zone import MeteorsCloud
from modules.physEngine.triggers.handler import TriggerHandler
from modules.physEngine.projectiles.mine_master import Mine_type1, Mine_type2
#==SPACE==#

class MapLoader:
    def __init__(self):
        self.hBodies = hBodyPool_Singleton()
        self.cShips = ShipPool_Singleton()
        self.lBodies = lBodyPool_Singleton()
        self.grid_step = ConfigLoader().get("world.map_step", float)
#==SPACE==#

    def load_interactable(self):
        conteiners_num = 10
        spawn_radius = self.grid_step*3
        for i in range(0):
            pos_x = randint(-spawn_radius, spawn_radius)
            pos_y = randint(-spawn_radius, spawn_radius)
            self.lBodies.add(intact_Container(pos_x,pos_y))
#==SPACE==#

#==SPACE==#

    def proceed_command(self, command:Command):
        action = command.get_action()
        match action:
            case 'load_map': self.load_map_with_name(command.get_params()["map_name"])
#==SPACE==#

#==SPACE==#

    def load_map_with_name(self, map_name):
        self.hBodies.clear()
        self.cShips.clear()
        self.lBodies.clear()
        TriggerHandler().proceed_triggers_list()
        EntityIDGroupsController().clear()
#==SPACE==#

#==SPACE==#

        #Gconst = ConfigLoader().get("world.gravity_constant",float)
        #WorldPhysConstants().set_Gconst(Gconst)
        #TrajectoryPredictor_controller().update_physics()
#==SPACE==#

        try:
            map_data = json.load(open(f"maps/{map_name}"))
            for hbody_id in map_data["hBodies"]:
                hbody_object = self.get_hbody_from_description(map_data["hBodies"][hbody_id])
                if hbody_object:
                    self.hBodies.add(hbody_object)
#==SPACE==#

            for lbody_id in map_data["lBodies"]:
                is_ship, lbody_object = self.get_lbody_from_description(lbody_id, map_data["lBodies"][lbody_id])
                if lbody_object:
                    self.lBodies.add(lbody_object)
#==SPACE==#

            if "cShips" in map_data:
                for ship_id in map_data["cShips"]:
                    ship_obj = self.get_ship_from_description(ship_id, map_data["cShips"][ship_id])
                    if ship_obj:
                        self.cShips.spawn(ship_obj)
#==SPACE==#
                        
#==SPACE==#

        except Exception as e:
            print("load_map_with_name", map_name, repr(e))
            print(traceback.format_exc())
            self.hBodies.clear()
            self.cShips.clear()
            self.lBodies.clear()
#==SPACE==#

#==SPACE==#

        TrajectoryPredictor_controller().update_hbodies_location()
#==SPACE==#

#==SPACE==#

    def get_hbody_from_description(self, descr):
        try:
            match descr["type"]:
                case "hBody":
                    object = hBody(0,0)
                case "ResourceAsteroid":
                    object = ResourceAsteroid(0,0)
                case 'WormHole':
                    object = WormHole(0,0)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                        
            object.put_description(descr, forced = True)
            return object
        except Exception as e:
            print("map loader", repr(e))
        return None
#==SPACE==#

    def get_ship_from_description(self, mark_id, descr):
        result = None
        match descr["type"]:
            case "Ship":
                result = Ship(900000,900000, mark_id=mark_id)
#==SPACE==#
                
            case "NPC_Ship":
                result = NPC_Ship(900000,900000, mark_id=mark_id)
#==SPACE==#

        if result:
            result.put_description(descr)
        return result
#==SPACE==#

#==SPACE==#
        
    def get_lbody_from_description(self, mark_id, descr):
        pos_x = descr["pos"][0]
        pos_y = descr["pos"][1]
        is_ship = False #controllable ship
        result = None
        match descr["type"]:
            #case "ae_Ship":
            #    result = Ship(pos_x,pos_y, mark_id=mark_id)
            #    is_ship = True
            #case "NPC_Ship":
            #    result = NPC_Ship(pos_x,pos_y, mark_id=mark_id)
            #    is_ship = True
            case 'ShipDebris':
                result = ShipDebris(pos_x,pos_y)
#==SPACE==#

            case 'MeteorsCloud':
                result = MeteorsCloud(pos_x,pos_y)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
            case 'QuantumShadow':
                result = QuantumShadow(pos_x, pos_y)
#==SPACE==#

            case 'SpaceStation':
                result = SpaceStation(pos_x, pos_y, mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
            case 'WormHole':
                result = WormHole(pos_x, pos_y)
#==SPACE==#

            case 'SpaceStationDebris':
                result = SpaceStationDebris(pos_x, pos_y, mark_id)
#==SPACE==#

            case 'Mine_type1':
                result = Mine_type1(pos_x, pos_y)
#==SPACE==#

#==SPACE==#
                
            case 'Mine_type2':
                result = Mine_type2(pos_x, pos_y)
#==SPACE==#

#==SPACE==#

        if result:
            result.put_description(descr,True)
#==SPACE==#

        return is_ship, result
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
        ship1 = Ship(pos_x,pos_y, mark_id=mark_id)
        return ship1
#==SPACE==#

    def load_map(self):
        #self.load_map_with_name("triangle3.json")
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        """self.hBodies.clear()
#==SPACE==#

        count = randint(1,4)
#==SPACE==#

        scale = 1
        area_radius = int(scale*self.grid_step)
        for i in range(count):
            pos_x = randint(-area_radius,area_radius)
            pos_y = randint(-area_radius,area_radius)
            self.hBodies.add(hBody(pos_x, pos_y,200))"""
#==SPACE==#

        """for pos_x, pos_y, gr in [(-2*self.grid_step,0,self.grid_step),
                                    (2*self.grid_step,0,self.grid_step),
                                    (0,0,self.grid_step)]:
            self.hBodies.add(ResourceAsteroid(pos_x, pos_y,gr))
#==SPACE==#

        for pos_x, pos_y, gr in [
                                    (-self.grid_step,-0.866*2*self.grid_step,self.grid_step),
                                    (self.grid_step,-0.866*2*self.grid_step,self.grid_step),
                                    (-self.grid_step,0.866*2*self.grid_step,self.grid_step),
                                    (self.grid_step, 0.866*2*self.grid_step,self.grid_step),
                                    ]:
            self.hBodies.add(hBody(pos_x, pos_y,gr))"""
        #TrajectoryPredictor_controller().update_hbodies_location()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def load_ships(self):
        ConfigLoader().update()
        self.cShips.clear()
        self.lBodies.clear()
        #ship1 = Ship(randint(-1*self.grid_step, 0),randint(100, self.grid_step), mark_id="NORD")
        ship1 = Ship(-self.grid_step,0, mark_id="Sirocco")
        self.cShips.spawn(ship1)
        #ship2 = Ship(randint(0, 1*self.grid_step),randint(100, self.grid_step), mark_id="WEST")
        ship2 = Ship(self.grid_step,0, mark_id="WEST")
        self.cShips.spawn(ship2)
        #self.cShips.spawn(randint(-50, 50),randint(-self.grid_step, -100), mark_id="SOUTH")
        self.load_interactable()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            

###===###.\back01\modules\network\WebsocketController.py
import secrets
import asyncio
import websockets
import json
from modules.utils import Command, ConfigLoader, CommandLogger
from modules.sectorServer import EngineSector_interactor
import time
#from modules.physEngine.predictor import launch_new_TrajectoryPredictor_controller
#==SPACE==#

class ConnectionController:
    #токен коннекшна должен быть связан с id viewer и с id controller
    connections = {}
    connection_ips = {}
    controlled_entiies = {}
    last_activities = {}
    server = EngineSector_interactor()
#==SPACE==#

#==SPACE==#

#==SPACE==#

    async def handler(websocket):
        print("connection started")
        token = secrets.token_urlsafe(12)
        ConnectionController.connections[token] = websocket
        ConnectionController.controlled_entiies[token] = None
        ConnectionController.connection_ips[token] = websocket.origin
        ConnectionController.last_activities[token] = time.perf_counter()
        try:
            async for message in websocket:
                ConnectionController.last_activities[token] = time.perf_counter()
                message_data = json.loads(message)
                command = Command(message_data)
                CommandLogger().add(command)
                if command.contains_level("connection"):
                    ConnectionController.proceed_command(token, command)
#==SPACE==#

                #if command.contains_level("predictor"):
                # launch_new_TrajectoryPredictor_controller()
                else:
                    ConnectionController.server.proceed_command(message_data)
        except Exception as e:
            print(repr(e))
#==SPACE==#

#==SPACE==#

        print("connection terminated")
#==SPACE==#

    async def main():
        ip = ConfigLoader().get("system.ip")
        port = ConfigLoader().get("system.ws_port", int)
        async with websockets.serve(ConnectionController.handler, ip, port):
            while 1:await asyncio.sleep(0.04)
#==SPACE==#

    def clear_connection(token):
        ConnectionController.connections.pop(token)
        ConnectionController.controlled_entiies.pop(token)
        ConnectionController.connection_ips.pop(token)
        ConnectionController.last_activities.pop(token)
#==SPACE==#

    async def clear_broken_connections():
        while 1:
            timestamp_now = time.perf_counter()
            tokens= list(ConnectionController.connections.keys())
            for token in tokens:
                delta = timestamp_now-ConnectionController.last_activities[token]
                if delta>2:
                    await ConnectionController.connections[token].close()
            await asyncio.sleep(2)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

    def proceed_command(token, command:Command):
        if command.get_action() == "take_control_on_entity":
            ConnectionController.controlled_entiies[token] = command.get_params()['target_id']
#==SPACE==#

#==SPACE==#

    async def broadcast():
        while 1:
            try:
                tokens2delete = []
                for token in ConnectionController.connections:
                    try:
                        global_map_data = ConnectionController.server.get_sector_map(ConnectionController.controlled_entiies[token])
                        await ConnectionController.connections[token].send(json.dumps(global_map_data))
                    except websockets.ConnectionClosedOK:
                        tokens2delete.append(token)
#==SPACE==#

                for token in tokens2delete:
                    del ConnectionController.connections[token]
                    del ConnectionController.connection_ips[token]
            except Exception as e:
                print(repr(e))
                del ConnectionController.connections[token]
                del ConnectionController.connection_ips[token]
            await asyncio.sleep(0.02)

###===###.\back01\modules\physEngine\active_objects.py
import numpy as np
from modules.physEngine.core import hBodyPool_Singleton, CalculationUtilites
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.basic_objects import controllableBody, predictableBody
from modules.ship.shipPool import ShipPool_Singleton
from modules.physEngine.triggers.collector import TriggerQueue
from modules.physEngine.basic_objects import lBody
from modules.physEngine.world_constants import WorldPhysConstants
#==SPACE==#

from dataclasses import dataclass
from datetime import datetime, timedelta
#==SPACE==#

from modules.utils import ConfigLoader,PerformanceCollector, get_dt_ms
#==SPACE==#

class destructableObject():
    def __init__(self, mark_id):
        self.mark_id = mark_id
#==SPACE==#

    def self_destruct(self):
        TriggerQueue().add("selfdestruct", self.mark_id, {})
        self.status = "destroyed"
#==SPACE==#

#==SPACE==#

#==SPACE==#

from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
#==SPACE==#

class ae_Ship(controllableBody):
    def __init__(self, x, y, mark_id = None, ship_subtype = "ae_Ship"):
        super().__init__(x, y, mark_id)
        self.desctiption["type"] = ship_subtype
        if ship_subtype == "Kraken":
            self.desctiption["marker_type"] = ship_subtype
        self.set_predictor_state(True)
        self.close_scanrange = 150
#==SPACE==#

        self.radar_levels = [
            (0.25, "activity"),
            (0.5, "active_ship"),
        ]
#==SPACE==#

        if ship_subtype == "Kraken":
            self.radar_levels = [
            (2, "activity"),
        ]
#==SPACE==#

        self.mapped_hbodies = set()
        self.last_radarscan_timestep = datetime.now()
        self.scan_marks = []
        self.distant_scanrange = 300
        self.distant_scanrange_arc = 10
        self.distant_scanrange_arc_p1 = 95
        self.distant_scanrange_arc_p2 = 85
        self.distant_scanrange_dir = 90
#==SPACE==#

        EntityIDGroupsController().add(self.mark_id, ["radar_detectable", "id_labels_detectable", "is_ships"])
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def set_close_scanrange(self , value):
        self.close_scanrange = value
#==SPACE==#

    def set_distant_scanrange(self , value):
        self.distant_scanrange = value
#==SPACE==#

    def set_distant_scanparams(self, scan_distance, scan_arc, scan_dir):
        if scan_distance:
            self.distant_scanrange = scan_distance
        if scan_arc:
            self.distant_scanrange_arc = scan_arc
            self.distant_scanrange_arc_p1 = self.distant_scanrange_dir+self.distant_scanrange_arc/2
            self.distant_scanrange_arc_p2 = self.distant_scanrange_dir-self.distant_scanrange_arc/2
#==SPACE==#

        if scan_dir:
            self.distant_scanrange_dir = scan_dir
            self.distant_scanrange_arc_p1 = self.distant_scanrange_dir+self.distant_scanrange_arc/2
            self.distant_scanrange_arc_p2 = self.distant_scanrange_dir-self.distant_scanrange_arc/2
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_interactble_objects_in_radius(self, interaction_radius):
        intact_objs = EntityIDGroupsController().get("interactable")
        bodies_ids = self.get_entities_ids_from_list_in_range(intact_objs, interaction_radius, False)
        return bodies_ids
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_hbodies_in_sight(self, close_radrange):
        bodies_idxs = self.hBodies.get_index_assosiated_idx_list(self.hbody_idx)
        result = {}
        all_body_descr = self.hBodies.get_bodies_description()
        for body_idx in bodies_idxs:
            result[body_idx] = all_body_descr[body_idx]
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def self_destruct(self):
        super().self_destruct()
        EntityIDGroupsController().remove(self.mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

    #def update_position(self):
    # if self.predictor_is_active:
    #  self.upload_state_to_predictor()
    # #return super().update_position()
#==SPACE==#

    def get_objects_in_sight(self, bodies_dict, close_radrange):
        #result = {}
        #bodies_ids = self.get_entities_ids_list_in_range(bodies_dict, close_radrange)
        #for body_id in bodies_ids:
        #  result[body_id]= bodies_dict[body_id].get_description(self.mark_id)
        result = self.lBodies.get_bodies_description()
        return result
#==SPACE==#

    def get_viewfield(self):
        nav_data = {
            'mark_id':self.mark_id,
            "observer_pos": self.get_position(),
            'observer_radius': self.close_scanrange,
            "hBodies": self.get_objects_in_sight(self.hBodies.bodies),
            "lBodies": self.get_objects_in_sight(self.lBodies.bodies),
        }
#==SPACE==#

        field_view = {
            "observer_id": self.mark_id,
            "nav_data": nav_data
        }
        return field_view
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_radar_mark_from_pos(self, tar_pos):
        tar_vector = tar_pos-self.get_position_np()
        tar_vector_norm = tar_vector/np.linalg.norm(tar_vector)
        tar_vector_norm = tar_vector_norm*self.close_scanrange
        marker_position = self.get_position_np()+tar_vector_norm
        return marker_position
#==SPACE==#

#==SPACE==#

    #returns only angle
    def get_hbodies_radar_marks(self, bodies_dict):
        marks = []
#==SPACE==#

        bodies_ids = self.get_entities_in_sector(self.hBodies.bodies, self.hBodies.bodies,
                                                self.distant_scanrange_arc_p1, self.distant_scanrange_arc_p2,
                                                self.distant_scanrange, hard = True)
        for body_id in bodies_ids:
            mark = bodies_dict[body_id].get_radar_mark(self.get_position_np(), self.distant_scanrange, self.close_scanrange)
            if mark:
                tar_pos = bodies_dict[body_id].get_position_np()
                #marker_position = self.get_radar_mark_from_pos(tar_pos)
                marks.append((mark,tar_pos.tolist()))
#==SPACE==#

#==SPACE==#

        return marks
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_pole_mark(self):
        marks = []
        distance2pole = np.linalg.norm(self.get_position_np())
        if distance2pole>self.close_scanrange:
            marker_position = self.get_radar_mark_from_pos(np.zeros(2))
            marks.append(("pole",marker_position.tolist()))
        return marks
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_ships_activity_radar_marks(self):
        ships_ids_potential = EntityIDGroupsController().get("radar_detectable")
        #ships_ids = self.get_entities_ids_from_list_in_interval(ships_ids_potential, self.close_scanrange, distant_scanrange)
        ships_ids = self.get_entities_in_sector(ships_ids_potential, self.lBodies.bodies,
                                                self.distant_scanrange_arc_p1, self.distant_scanrange_arc_p2, self.distant_scanrange)
#==SPACE==#

        marks = []
        for ship_mark in ships_ids:
            mark = self.lBodies[ship_mark].get_radar_mark(self.get_position_np(), self.distant_scanrange, self.close_scanrange)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

            #если корабль обнаружен
            if mark:
                tar_pos = self.lBodies[ship_mark].get_position_np()
                if mark == "active_ship":
                    marker_position = tar_pos
                else:
                    tar_hbody = hBodyPool_Singleton().get_gravity_affected_body(tar_pos)
                    #если корабль в гравитационном колодце
                    if tar_hbody:
                        #если тело видимо
                        if self.check_entity_in_range(tar_hbody.mark_id, self.close_scanrange):
                            marker_position = tar_pos
                        else:
                            marker_position = tar_hbody.get_position_np()
                    else:
                        marker_position = tar_pos
                marks.append(("activity",marker_position.tolist()))
        return marks
#==SPACE==#

    def get_radar_marks(self, radar_ping):
#==SPACE==#

        if datetime.now()-self.last_radarscan_timestep > radar_ping:
            self.last_radarscan_timestep = datetime.now()
            scan_marks = self.get_hbodies_radar_marks(self.hBodies.bodies)
            scan_marks2 = self.get_ships_activity_radar_marks()
            self.scan_marks = scan_marks+scan_marks2
        return self.scan_marks+self.get_pole_mark()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_visible_ships(self):
        visible_ships = self.get_entities_ids_from_list_in_range(EntityIDGroupsController().get("id_labels_detectable"),self.close_scanrange, False)
        return visible_ships
#==SPACE==#

    def get_nav_data(self, radar_ping):
#==SPACE==#

        hbodies_data= self.get_hbodies_in_sight(self.close_scanrange)
        lBodies_data = self.get_objects_in_sight(self.lBodies.bodies, self.close_scanrange)
        scan_marks = self.get_radar_marks(radar_ping)
#==SPACE==#

        visible_ships = self.get_visible_ships()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

        nav_data = {
            'mark_id':self.mark_id,
            "observer_pos": self.get_position(),
            'observer_radius': self.close_scanrange,
            "hBodies": hbodies_data,
            "lBodies": lBodies_data,
            "visible_ships": visible_ships,
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        nav_data["scan_marks"] = scan_marks
        return nav_data
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_description(self, requester_id = None):
        result = super().get_description(requester_id)
        result["close_scanrange"] = self.close_scanrange
        result["distant_scanrange"] = {
            "close_range":self.close_scanrange,
            "distant_range": self.distant_scanrange,
            "distant_dir":self.distant_scanrange_dir,
            "distant_arc":self.distant_scanrange_arc
        }
#==SPACE==#

        """if (requester_id==None) or (requester_id==self.mark_id):
            result["close_scanrange"] = self.close_scanrange
            result["distant_scanrange"] = self.distant_scanrange
        if requester_id:
            if requester_id!=self.mark_id:
                result["alias"] = "enemy"""
#==SPACE==#

        return result
#==SPACE==#

from modules.physEngine.basic_objects import staticBody
class SpaceStation(staticBody, lBody):
    def __init__(self, x,y, mark_id = None):
        staticBody.__init__(self)
        self.manual_init(False)
        lBody.__init__(self, x,y, mark_id)
        self.stabilize_orbit()
        self.radar_levels = [
            (0.1, "activity"),
            (0.3, "active_ship"),
        ]
        EntityIDGroupsController().add(self.mark_id, ["radar_detectable", "id_labels_detectable", "interactable", "stationary_orbit", "is_station"])
        self.hp = 1000
        self.max_hp = 1000
#==SPACE==#

#==SPACE==#

    def get_interact_description(self):
        return "interact"
#==SPACE==#
    
    def get_description(self, requester_id=None):
        result = super().get_description(requester_id)
        result["vel"] = self.get_velocity_np_static().tolist()
        return result
#==SPACE==#
    
    def put_description(self, descr, forced):
        super().put_description(descr, forced)
        if "pos" in descr and "vel" in descr:
                self.set_position_and_velocity_init(np.array(descr["pos"]), np.array(descr["vel"]))
                return
        if "vel" in descr:
                self.set_velocity(np.array(descr["vel"]))
        if "pos" in descr:
                self.set_position_np_manual(np.array(descr["pos"]))
#==SPACE==#
    
#==SPACE==#

    def get_velocity_np(self):
        return self.get_velocity_np_static()
#==SPACE==#

#==SPACE==#

    def get_short_description(self):
        return {
                "hp":f"{round(self.hp)}/{self.max_hp}",
                "pos":self.get_position()
                }
#==SPACE==#

#==SPACE==#
        
    def get_surrounding_hbodies_ids(self):
        return [self.hbody_idx]
#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def self_destroy(self):
        EntityIDGroupsController().remove(self.mark_id)
        TriggerQueue().add("station_defeat", self.mark_id, {})
        TriggerQueue().add("ship_defeat", self.mark_id+"[DEF]", {})
#==SPACE==#

    def activate_station_defence(self):
        defender_id = self.mark_id+"[DEF]"
        defender_level = 2
        if self.mark_id == "Selena":
            defender_id = "Galileo"
        if self.mark_id == "Medusa":
            if self.mark_id+"[DEF]" in self.lBodies.bodies:
                defender_id = "Otto"
                defender_level = 3
        TriggerQueue().add("activate_station_defence", self.mark_id, {"defender":defender_id, "defender_level":defender_level})
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def takes_damage(self, damage_value, damage_type = "explosion", damage_source = None):
        self.hp = self.hp-damage_value
        if self.hp<0:
            self.self_destroy()
#==SPACE==#

    def interact(self, interactor_id):
        pass
#==SPACE==#

#==SPACE==#

import random
import numpy as np
class QuantumShadow(lBody):
    def __init__(self, x, y, mark_id = None):
        super().__init__(x, y, "VanEick")
        self.marker_type = "QuantumShadow"
        self.stabilize_orbit()
        self.destability_radius = 50
        self.radar_levels = [
            (0.25, "activity"),
            (0.5, "active_ship"),
        ]
        EntityIDGroupsController().add(self.mark_id, ["radar_detectable", "id_labels_detectable"])
#==SPACE==#

        self.wormhole_position = self.hBodies["WormHole"].get_position_np()
        self.potential_start_points = self.get_potential_start_points()
#==SPACE==#

    def get_potential_start_points(self):
        result = []
        for body_idx in self.hBodies.bodies:
            distance = np.linalg.norm(self.wormhole_position - self.hBodies[body_idx].get_position_np())
            if 1200 < distance < 1400:
                result.append(body_idx)
        return result
#==SPACE==#

    def quantum_jump(self):
        if self.hbody_idx != "WormHole":
            potential_new_hbodies = self.hBodies.get_index_assosiated_idx_list(self.hbody_idx)
            current_distance = np.linalg.norm(self.wormhole_position - self.get_position_np())
            new_hbody_idx = self.hbody_idx
            for body_idx in potential_new_hbodies:
                tmp_distance = np.linalg.norm(self.wormhole_position - self.hBodies[body_idx].get_position_np())
                if tmp_distance < current_distance:
                    current_distance = tmp_distance
                    new_hbody_idx = body_idx
#==SPACE==#

#==SPACE==#
            
        else:
            new_hbody_idx = random.choice(self.potential_start_points)
#==SPACE==#

        position = self.hBodies[new_hbody_idx].get_random_stable_point()
        self.set_position_np_manual(position, random.choice([True,False]))
#==SPACE==#

#==SPACE==#

    def update_position(self):
        super().update_position()
        reachable_bodies = self.get_entities_ids_from_list_in_range(EntityIDGroupsController().get("is_ships"), self.destability_radius, False)
        if reachable_bodies:
            self.quantum_jump()
#==SPACE==#

#==SPACE==#


###===###.\back01\modules\physEngine\basic_objects.py
#==SPACE==#

import numpy as np
from modules.physEngine.world_constants import WorldPhysConstants
from modules.physEngine.core import TrajectoryCalculator
from modules.physEngine.predictor import TrajectoryPredictor_controller
from modules.physEngine.core import CalculationUtilites, basic_Body, hBody, hBodyPool_Singleton
from modules.physEngine.triggers.collector import TriggerQueue
from modules.utils import PerformanceCollector
#класс-реальный объект.
#длительность тактов предсказания ~3
#связан со своей "копией", которая в отдельном потоке
#генерирует предсказания
from modules.physEngine.core import hBodyStatsCalculator
#==SPACE==#

class lBody(TrajectoryCalculator):
    def __init__(self, x, y, mark_id = None):
        self.marker_type = self.__class__.__name__
        self.mark_id = mark_id if mark_id else str(id(self))
        pos = np.array([x,y])
        super().__init__(pos, np.array([0,0]),mark_id)
        self.is_detectable = False
#==SPACE==#

    def get_description(self,requester_id=None):
        res = {
            "mark_id": self.mark_id,
            "type": self.marker_type,
            "pos": self.positions[1].tolist(), #[self.positions[1][0].item(), self.positions[1][1].item()],
            "vel": self.velocities[1].tolist(),
            'marker_type':self.marker_type,
        }
        return res
#==SPACE==#

#==SPACE==#
        
class staticBody():
    def manual_init(self, is_cachable = True):
        self.stabilized = False
        self.stable_dphi = 0.0
        self.stable_phi = 0.0
        self.stable_distance_vector = np.array([100,0])
        self.clockwise = False
        self.is_cachable = is_cachable
#==SPACE==#

#==SPACE==#

    def do_cache(self):
        self.stabilized = False
        self.hbody_idx = None
        self.last_hbody_idx = None
#==SPACE==#

    def do_uncache(self):
        pass
#==SPACE==#

#==SPACE==#

    def get_velocity_np_static(self):
        radius = np.linalg.norm(self.stable_distance_vector)
        scalar_V = abs(self.stable_dphi*radius)
        add_phi = 90
        if self.clockwise:
            add_phi = -90
        req_phi = self.stable_phi+add_phi
        vector_V = CalculationUtilites.rotate_vector(np.array([scalar_V,0]),req_phi )
        return vector_V
#==SPACE==#

#==SPACE==#

    def set_position_np_manual(self, position, clockwise=False):
        self.stabilized = False
        self.clockwise = clockwise
        return super().set_position_np_manual(position, clockwise)
#==SPACE==#

    def try_stabilization_static(self):
        if self.hbody_idx:
            distance = self.get_distance2entity(self.hbody_idx)
            self.stable_distance_vector = np.array([distance,0])
            current_vector = self.get_position_np() - self.hBodies.bodies[self.hbody_idx].get_position_np()
#==SPACE==#

#==SPACE==#
                
            #self.stable_distance_vector = CalculationUtilites.rotate_vecto_rad(self.stable_distance_vector, current_phi_rad)
            T = hBodyStatsCalculator.get_T(self.hBodies[self.hbody_idx].mass, distance)
            T_ticks = T*WorldPhysConstants().get_ticks_per_second()
#==SPACE==#

            current_phi_rad = CalculationUtilites.get_radangle_between(current_vector, self.stable_distance_vector)
            self.stable_phi = current_phi_rad*180/3.14
            self.stable_dphi = 360/T_ticks
            self.clockwise = self.get_clockwise()
            if self.clockwise:
                self.stable_dphi = - self.stable_dphi
            self.stabilized = True
#==SPACE==#

#==SPACE==#

    def get_clockwise(self):
        vector2hbody = hBodyPool_Singleton().get(self.hbody_idx).get_position_np() - self.get_position_np()
        angle = CalculationUtilites.get_radangle_between(self.velocities[1], vector2hbody)
        angle2 = CalculationUtilites.get_radangle_between(self.velocities[1]*-1, vector2hbody)
        if 0<=angle<=3.14:
            return True
        return False
#==SPACE==#

    def update_position(self):
        if not self.stabilized:
            super().update_position()
            self.try_stabilization_static()
#==SPACE==#

#==SPACE==#
            
        else:
            self.stable_phi = self.stable_phi+self.stable_dphi
            self.positions[0] = self.positions[1]
            self.positions[1] = self.hBodies.bodies[self.hbody_idx].get_position_np() + CalculationUtilites.rotate_vector(self.stable_distance_vector, self.stable_phi)
            self.positions[2] = self.positions[1]
#==SPACE==#

#==SPACE==#

class dynamicBody(TrajectoryCalculator):
    def __init__(self, x, y, mark_id = None):
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.marker_type = self.__class__.__name__ # 'unknown'
        self.mark_id = mark_id if mark_id else str(self.__class__.__name__)+'_'+str(id(self))
        pos = np.array([x,y])
        stable_velocity_vector = CalculationUtilites.get_stable_velocity(pos)
        super().__init__(pos, stable_velocity_vector,mark_id)
        self.is_detectable = True
        self.desctiption = {
            "mark_id": self.mark_id,
            "type": self.type,
            'marker_type':self.marker_type,
            "alias": "neutral"
        }
    def set_marker_type(self, marker_type):
        self.marker_type = marker_type
        self.desctiption['marker_type'] = marker_type
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_description(self,requester_id=None):
        self.desctiption["pos"] = self.positions[1].tolist()
        self.desctiption["vel"] = self.velocities[1].tolist()
        return self.desctiption
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def put_description(self, descr, forced = False):
        super().put_description(descr, forced)
        if "pos" in descr and "vel" in descr:
            self.set_position_and_velocity_init(np.array(descr["pos"]), np.array(descr["vel"]))
            return
        if "vel" in descr:
            self.set_velocity(np.array(descr["vel"]))
        if "pos" in descr:
            self.set_position_np_manual(np.array(descr["pos"]))
#==SPACE==#

#==SPACE==#
        
#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def self_destruct(self):
        TriggerQueue().add("selfdestruct", self.mark_id, {})
        self.status = "destroyed"
#==SPACE==#

#==SPACE==#

class predictableBody(dynamicBody):
    def __init__(self, x, y, mark_id = None):
        super().__init__(x, y, mark_id)
        self.predictor_is_active = False
        self.task_uploaded = True
        self.predictor_depth = 10
        self.run_predictor()
#==SPACE==#

    def run_predictor(self):
        try:
            self.predictor_controller = TrajectoryPredictor_controller()
            m = self.mark_id
            self.predictor_controller.login(m)
        except Exception as e:
            print(repr(e))
#==SPACE==#

    def upload_state_to_predictor(self):
        params = {"pos":self.positions[1].tolist(),
                    "vel":self.velocities[1].tolist(),
                    "mass":self.mass,
                    "hbody_idx":self.hbody_idx,
                    "last_hbody_idx":self.last_hbody_idx,
                    "depth":self.predictor_depth}
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.task_uploaded = self.predictor_controller.upload_task(self.mark_id, params)
#==SPACE==#

#==SPACE==#

    def set_predictor_state(self, state:bool):
        self.predictor_is_active = state
        if state:
            self.predictor_controller.login(self.mark_id)
        else:
            self.predictor_controller.logout(self.mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_prediction_depth(self, duration:float):
        self.predictor_depth = float(duration)
#==SPACE==#

    def get_prediction(self):
        if self.predictor_is_active:
            return self.predictor_controller.get_prediction(self.mark_id)
        return []
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def update_position(self):
        if self.predictor_is_active:
            self.upload_state_to_predictor()
        super().update_position()
#==SPACE==#

    def get_description(self,requester_id=None):
        res = super().get_description(requester_id)
        res["predictions"] = self.get_prediction()
        return res
#==SPACE==#

class controllableBody(predictableBody):
    def __init__(self, x, y, mark_id = None):
        super().__init__(x,y,mark_id)
        self.acceleration = 0.0
        self.rotation = 0.0
        self.direction = 0.0
        self.is_detectable = True
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#region АКТИВАЦИЯ ДВИГАТЕЛЕЙ
    #prograde - по направлению движения
    def set_acceleration(self, value):
        self.acceleration = value
#==SPACE==#

    #normal - от поверхности планеты
    def set_rotation(self, value):
        self.rotation = value
#==SPACE==#

    def is_underAcceleration(self):
        return (self.acceleration!=0)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    #ускорение от активации двигателей вдоль касательной(prograd)
    def get_dA_artificial(self):
        self.next_step(2)
        next_position = self.positions[2]
        #вектор касательной
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        tangent = np.array([0,1])
        tangent = CalculationUtilites.rotate_vector(tangent,self.direction)
        #раскладываем на компоненты
        acceleration = CalculationUtilites.get_projections(self.acceleration, tangent)
        return acceleration
#endregion
#==SPACE==#

    def update_position(self):
        if self.rotation!=0:
            self.direction = self.direction+WorldPhysConstants().get_timestep()*self.rotation
#==SPACE==#

        if self.is_underAcceleration():
            acceleration = self.get_acceleration_gravity(self.positions[1])+self.get_dA_artificial()
            self.velocities[2]=self.velocities[1]+WorldPhysConstants().get_timestep()*acceleration
        super().update_position()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_description(self, requester_id=None):
        res = super().get_description(requester_id)
        res["direction"] = self.direction
        return res
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\modules\physEngine\core.py
import numpy as np
from modules.physEngine.world_constants import WorldPhysConstants
from modules.utils import ConfigLoader
#Астероиды, прибиты гвоздями к небу
#==SPACE==#

from modules.physEngine.triggers.collector import TriggerQueue
from modules.physEngine.marks_collector import MarksCollector
from modules.utils import ConfigLoader,PerformanceCollector, get_dt_ms
from datetime import datetime
from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
#==SPACE==#

class basic_Body:
    def __init__(self, mark_id = None):
        self.hBodies = hBodyPool_Singleton()
        self.lBodies = lBodyPool_Singleton()
        self.mark_id = mark_id if mark_id else str(id(self))
        self.marker_type = self.__class__.__name__
        self.radar_visibility = 1
        self.radar_levels = [
            (0, "hbody"),
        ]
        self.type = self.__class__.__name__
        pass
#==SPACE==#

    def set_visibility(self, value):
        self.radar_visibility = 1
#==SPACE==#

    def get_position_np(self):
        return np.zeros(2)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_entities_ids_list_in_range(self, bodies_dict, distance, include_myself = True):
        result = []
        for body_id in bodies_dict:
            if (not include_myself) and (body_id==self.mark_id):
                continue
            dist2body = self.get_distance2entity(body_id)
            if dist2body<distance:
                result.append(body_id)
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_entities_ids_list_in_interval(self, bodies_dict, distance1, distance2, include_myself = True):
        result = []
        for body_id in bodies_dict:
            if (not include_myself) and (body_id==self.mark_id):
                continue
            dist2body = self.get_distance2entity(body_id)
            if distance2>=dist2body>=distance1:
                result.append(body_id)
        return result
#==SPACE==#

#==SPACE==#

    def get_entities_ids_list_outof_range(self, bodies_dict, distance, include_myself = True):
        result = []
        for body_id in bodies_dict:
            if (not include_myself) and (body_id==self.mark_id):
                continue
            dist2body = self.get_distance2entity(body_id)
            if dist2body>=distance:
                result.append(body_id)
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_entities_ids_from_list_in_range(self, body_ids, distance, include_myself = True):
        try:
            result = []
            for body_id in body_ids:
                if (not include_myself) and (body_id==self.mark_id):
                    continue
                dist2body = self.get_distance2entity(body_id)
                if dist2body<distance:
                        result.append(body_id)
            return result
        except Exception as e:
            print(e)
            return []
#==SPACE==#

#==SPACE==#
        
    def get_entities_ids_from_list_in_interval(self, body_ids, distance1, distance2, include_myself = True):
        result = []
        for body_id in body_ids:
            if (not include_myself) and (body_id==self.mark_id):
                continue
            dist2body = self.get_distance2entity(body_id)
            if distance2>=dist2body>=distance1:
                    result.append(body_id)
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_entities_in_sector(self, body_ids, body_dict, arc_1, arc_2, distance = None, hard = False):
        result = []
        for body_id in body_ids:
            if distance:
                dist2body = 9000000
                if hard:
                    dist2body = self.get_distance2entity_hard(body_dict[body_id])
                else:
                    dist2body = self.get_distance2entity(body_id)
                if dist2body>distance: continue
            body_pos_vec = body_dict[body_id].get_position_np()-self.get_position_np()
            angle_tar = CalculationUtilites.get_abs_angle_degrees_from_zero(body_pos_vec)
            if CalculationUtilites.is_in_sector(angle_tar, arc_1, arc_2):
                result.append(body_id)
        return result
#==SPACE==#

    def get_entities_ids_from_category_in_range(self, category_name, distance, include_myself = True):
        body_ids = EntityIDGroupsController().get(category_name)
        result = self.get_entities_ids_from_list_in_range(body_ids, distance, include_myself)
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def check_entity_in_range(self, key, distance):
        return self.get_distance2entity(key)<distance
#==SPACE==#

    def get_distance2entity(self, key):
        distance = CrossDistancePool().get(self.mark_id, key)
        if distance: return distance
        bpool = self.lBodies
        if key in self.hBodies.bodies:
            bpool = self.hBodies
        return self.get_distance2entity_hard(bpool[key])
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_distance2position(self, position):
        return np.linalg.norm(position-self.get_position_np())
#==SPACE==#

    def get_distance2entity_hard(self, any_body):
        req_pos = any_body.get_position_np()
        return np.linalg.norm(req_pos-self.get_position_np())
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_angle_between(self, position):
        vector = self.get_position_np()-position
        vector_zero = np.array([1,0])
        alpha_rad = CalculationUtilites.get_radangle_between(vector,vector_zero)
        return alpha_rad
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_radial_coordinates(self, position):
        vector = position-self.get_position_np()
        vector_zero = np.array([1,0])
        alpha_rad = CalculationUtilites.get_radangle_between(vector,vector_zero)
        return alpha_rad, np.linalg.norm(vector)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_decart_relative_coordinates(self, alpha_rad, distance):
        vector = np.array([distance,0])
        vector_rotated = CalculationUtilites.rotate_vecto_rad(vector, alpha_rad)
        return self.get_position_np()+vector_rotated
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_scan_level(self, scan_source, scan_power, close_radar_distance):
        distance = np.linalg.norm(scan_source-self.get_position_np())
#==SPACE==#

        if distance>scan_power: return -1
        if distance<=close_radar_distance: return -1
        # distance/scan_power - какова дистанция в процентах от максимального радиуса радара. 1 - на пределе видимости, 0 - в упор.
        # scan_level - обратная величина. 0 - на пределе, 1 - на границе обычного радара
        # временное решение!
        # маркер - это процент расстояния от границ обычного радара до дальнего
        # за границами дальнего не видно ничего и никак.
        # видимость - это насколько в процентах хорошо видно.
        # scan_level = scan_level*3
        # Видимость 1 - без штрафов и бонусов. Видимость 0.5 - тебя видно в два раза хуже
        scan_level = 1-(distance-close_radar_distance)/(scan_power-close_radar_distance)
        scan_level = scan_level*self.radar_visibility
        return scan_level
#==SPACE==#

    def get_radar_mark(self, scan_source, scan_power, close_radar_distance):
        scan_level = self.get_scan_level(scan_source, scan_power, close_radar_distance)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
        mark = None
        for level in self.radar_levels:
            if scan_level>level[0]:
                mark = level[1]
#==SPACE==#

        return mark
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def put_description(self, descr, forced):
        pass
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
import random
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

class hBody(basic_Body):
    def __init__(self, x, y, r=100, m=10):
        super().__init__()
        self.lBodies = lBodyPool_Singleton()
        self.position = np.array([x,y])
        self.gravity_well_radius = r
        self.mass = ConfigLoader().get("world.mass_coeff", float)*self.gravity_well_radius
        self.critical_r = ConfigLoader().get("world.critical_r_percentage", float)*self.gravity_well_radius
        self.gravity_well_linear_percentage = ConfigLoader().get("world.gravity_well_linear_percentage", float)
        self.mark_id = str(id(self))
        self.lbodies_in_gwell = []
#==SPACE==#

        self.is_cached = False
        self.cached_lbodies = []
            # "h_body"
        pass
#==SPACE==#

    def export_descr(self):
        return({
            'pos_x':self.position[0],
            'pos_y':self.position[1],
            'mass': self.mass,
            'gravity_well_radius': self.gravity_well_radius,
            'mark_id': self.mark_id,
            'type':self.type,
            'marker_type':self.marker_type,
        })
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def import_descr(self, json_descr):
        self.position[0] = json_descr["pos_x"]
        self.position[1] = json_descr["pos_y"]
        self.mass = json_descr["mass"]
        self.gravity_well_radius = json_descr["gravity_well_radius"]
        self.critical_r = ConfigLoader().get("world.critical_r_percentage", float)*self.gravity_well_radius
        self.mark_id = json_descr["mark_id"]
        self.marker_type = json_descr["type"]
#==SPACE==#

#==SPACE==#

    def get_position(self): #возвращает [x,y,r]
        return [self.position[0].item(), self.position[1].item()]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_position_np(self):
        return self.position
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_position_np_manual(self, position, clockwise = False):
        self.position = position
#==SPACE==#

#==SPACE==#

    def get_distance2position_from_border(self, position):
        return self.get_distance2position(position)-self.gravity_well_radius
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_description(self,requester_id=None):
        return {
                "mark_id": self.mark_id,
                "type":self.type,
                "pos":[self.position[0].item(), self.position[1].item()],
                "mass":self.mass,
                "gr": self.gravity_well_radius,
                'critical_r': self.critical_r,
                'marker_type':self.marker_type,
            }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def put_description(self, json_descr, forced = False):
        self.marker_type = json_descr["marker_type"]
        self.position = np.array(json_descr["pos"])
        self.gravity_well_radius = json_descr["gr"]
        self.mass = ConfigLoader().get("world.mass_coeff", float)*self.gravity_well_radius
        self.critical_r = ConfigLoader().get("world.critical_r_percentage", float)*self.gravity_well_radius
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        #self.critical_r = ConfigLoader().get("world.critical_r_percentage", float)*self.gravity_well_radius
        if forced:
            self.mass = json_descr["mass"]
            if "critical_r" in json_descr:
                self.critical_r = json_descr["critical_r"]
            self.mark_id = json_descr["mark_id"]
            self.type = json_descr["type"]
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def is_position_in_gravity_well(self, pos):
        distance = np.linalg.norm(self.position - pos)
        return distance<self.gravity_well_radius
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def add_in_gwell(self, mark_id):
        if mark_id not in self.lbodies_in_gwell:
            self.lbodies_in_gwell.append(mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def del_from_gwell(self, mark_id):
        if mark_id in self.lbodies_in_gwell:
            self.lbodies_in_gwell.remove(mark_id)
#==SPACE==#

    def get_lbodies_in_gwell(self):
        return self.lbodies_in_gwell
#==SPACE==#

#==SPACE==#

    def cache_static_lbodies(self, force = False):
        if not force:
            if self.is_cached: return
            self.is_cached = True
        to_del = []
        for lbody_idx in self.lbodies_in_gwell:
            if hasattr(self.lBodies[lbody_idx],"do_cache"):
                if self.lBodies[lbody_idx].is_cachable:
                    self.lBodies[lbody_idx].do_cache()
                    self.cached_lbodies.append(self.lBodies[lbody_idx])
                    to_del.append(lbody_idx)
#==SPACE==#

        for lbody_idx in to_del:
            self.lBodies.delete(lbody_idx)
#==SPACE==#

    def uncache_static_lbodies(self, force = False):
        if not force:
            if not self.is_cached: return
            self.is_cached = False
        for lbody in self.cached_lbodies:
            self.lBodies.add(lbody)
            self.lBodies[lbody.mark_id].do_uncache()
        self.cached_lbodies = []
#==SPACE==#

    def check_cached_bodies(self):
        ships = self.get_entities_ids_from_category_in_range("is_ships", 1000)
        if not ships:
            self.cache_static_lbodies()
        else:
            self.uncache_static_lbodies()
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def step(self):
        bodies_ids = self.get_entities_ids_from_list_in_range(self.lbodies_in_gwell, self.critical_r, False)
        for body_id in bodies_ids:
            TriggerQueue().add("hBodyCollision", self.mark_id, {"target":body_id})
#==SPACE==#

    def get_random_stable_point(self):
        distance = random.uniform(self.critical_r+1, self.gravity_well_radius*self.gravity_well_linear_percentage-1)
        angle = random.uniform(0,360)
        position = CalculationUtilites.rotate_vector(np.array([distance,0]),angle)+self.position
        return position
#==SPACE==#

import math
#==SPACE==#

#всё что летает(корабли и ракеты)
#не может висеть с нулевой скоростью
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#базоый класс для объектов и для их траекторий
#моделирует тело без движков, которое просто летит под действием сил грацитации
#вычислительная сложность за итерацию - О(1)
class TrajectoryCalculator(basic_Body):
    def __init__(self, pos,vel, mark_id = None):
        super().__init__(mark_id)
        self.predictions_count = 3 #минимальное значение
        self.prediction_count_maxlimit = 250
        self.hBodies = hBodyPool_Singleton()
        self.lBodies = lBodyPool_Singleton()
        self.mass = 1.0
        self.hbody_idx = None
        self.last_hbody_idx = None
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.positions = np.zeros([self.predictions_count,2],dtype =np.float32)
        self.velocities = np.zeros([self.predictions_count,2],dtype =np.float32)
        #текущая в момент времени позиция лежит по индексу 1
        #по индексу ноль - координаты на прошлом шаге
        self.debug_output = False
        self.is_predictor = False
        self.set_position_and_velocity_init(pos,vel)
        self._surrounding_update_frame = WorldPhysConstants().current_frame()
        self._surrounding_hbodies = []
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def set_position_and_velocity_init(self, pos, vel):
        for i in range(self.predictions_count):
            self.positions[i] = pos
            self.velocities[i] = vel
#==SPACE==#

    def set_position_np_manual(self, position, clockwise = False):
        self.positions[0] = position
        vel = CalculationUtilites.get_stable_velocity(position)
        if clockwise:
            vel = vel*-1
        self.velocities[0] = vel
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        for i in range(1,self.predictions_count):
            self.next_step(i)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

    def _get_surrounding_hbodies_ids(self):
        self._surrounding_update_frame = WorldPhysConstants().current_frame()
        if self.hbody_idx:
            return [self.hbody_idx]
        return self.hBodies.get_index_assosiated_idx_list(self.last_hbody_idx)
#==SPACE==#

    def get_surrounding_hbodies_ids(self):
        if WorldPhysConstants().current_frame()!=self._surrounding_update_frame:
            self._surrounding_hbodies = self._get_surrounding_hbodies_ids()
        return self._surrounding_hbodies
#==SPACE==#

    def _memset_grid(self, n_cells:int):
        pos_backup = self.positions[:2]
        vel_backup = self.velocities[:2]
        predictions_count = min(n_cells, self.prediction_count_maxlimit)
        self.positions = np.zeros([predictions_count,2],dtype =np.float32)
        self.velocities = np.zeros([predictions_count,2],dtype =np.float32)
        self.positions[:2] = pos_backup
        self.velocities[:2] = vel_backup
#==SPACE==#

    def get_timestep(self):
        return WorldPhysConstants().get_timestep()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_Gconst(self):
        return WorldPhysConstants().get_Gconst()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_position_and_velocity(self, pos, vel):
        self.positions[0] = pos
        self.velocities[0] = vel
        for i in range(1,self.predictions_count):
            self.next_step(i)
#==SPACE==#

    def set_velocity(self, vel):
        self.velocities[0] = vel
        for i in range(1,self.predictions_count):
            self.next_step(i)
#==SPACE==#

    def update_predictions(self):
        self.velocities[:-1] = self.velocities[1:]
        self.positions[:-1] = self.positions[1:]
        self.next_step(self.predictions_count-1)
#==SPACE==#

    def next_step(self, n_iter):
        assert n_iter!=0, "can not be first step in grid"
        acceleration = self.get_acceleration(self.positions[n_iter-1])
        self.velocities[n_iter] = self.velocities[n_iter-1]+acceleration*self.get_timestep()
        self.positions[n_iter] = self.positions[n_iter-1]+self.velocities[n_iter]*self.get_timestep()
#==SPACE==#

    def get_acceleration(self, position):
        return self.get_acceleration_gravity(position)
#==SPACE==#

#==SPACE==#

    def set_current_dwell(self, new_hbody_idx):
        if self.hbody_idx == new_hbody_idx: return
        self.delete_self_from_dwell()
        self.hbody_idx = new_hbody_idx
        self.add_self_in_dwell()
#==SPACE==#

    def add_self_in_dwell(self):
        if self.is_predictor: return
        if self.hbody_idx in self.hBodies.bodies:
            self.hBodies[self.hbody_idx].add_in_gwell(self.mark_id)
#==SPACE==#

    def delete_self_from_dwell(self):
        if self.is_predictor: return
        if self.hbody_idx in self.hBodies.bodies:
            self.hBodies[self.hbody_idx].del_from_gwell(self.mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_acceleration_gravity(self, position):
        self.last_hbody_idx = self.hbody_idx if self.hbody_idx else self.last_hbody_idx
        need_update_hbody_idx = False
#==SPACE==#

        tmp_hbody_idx = self.hbody_idx
        if self.hbody_idx:
            is_hbody_idx_actual = self.hBodies.is_position_in_gravity_well(position, self.hbody_idx)
            if not is_hbody_idx_actual:
                self.delete_self_from_dwell()
                need_update_hbody_idx = True
        else:
            need_update_hbody_idx = True
#==SPACE==#

#==SPACE==#

        if need_update_hbody_idx:
            tmp_hbody_idx = self.hBodies.get_gravity_affected_body_idx(position, self.last_hbody_idx)
            is_hbody_idx_actual = self.hBodies.is_position_in_gravity_well(position, tmp_hbody_idx)
            if is_hbody_idx_actual:
                self.set_current_dwell(tmp_hbody_idx)
#==SPACE==#

#==SPACE==#

#==SPACE==#
    
#==SPACE==#

        vector = self.hBodies.get_single_gravity(position, self.mass, tmp_hbody_idx)
#==SPACE==#

#==SPACE==#
            
        #if self.hbody_idx:
        # vector = self.hBodies.get_single_gravity(position, self.mass,self.hbody_idx )
        # return vector
        #else:
        # vector = self.hBodies.get_summary_gravity(position, self.mass, self.last_hbody_idx) #если вне гравитационного колодца
#==SPACE==#

        if self.debug_output:
#==SPACE==#

            if np.linalg.norm(vector)==0:
                print("get_acceleration_gravity", self.hbody_idx, self.last_hbody_idx)
        return vector
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def update_position(self):
        self.update_predictions()
#==SPACE==#

    def get_position(self):
        return [round(a,2) for a in self.positions[1].tolist()]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_position_np(self):
        return self.positions[1]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_velocity_np(self):
        return self.velocities[1]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_abs_velocity(self):
        #mag = np.sqrt(self.velocities[1].dot(self.velocities[1]))
        c1 = float(self.velocities[1][0])
        c2 = float(self.velocities[1][1])
        return math.sqrt(c1*c1+c2*c2)
        #return float(np.linalg.norm(self.velocities[1]))
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_prediction(self):
        return []
        #return self.positions[::].tolist()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def stabilize_orbit(self, offset = 0):
        position_tmp = self.get_position_np()
        related_hbody:hBody = self.hBodies.get_gravity_affected_body(position_tmp)
        if not related_hbody: return
        alpha_rad, distance = related_hbody.get_radial_coordinates(position_tmp)
        position_new = related_hbody.get_decart_relative_coordinates(alpha_rad, distance+offset)
        stable_velocity_vector = CalculationUtilites.get_stable_velocity(position_new, self.velocities[1])
        self.set_position_and_velocity(position_new,stable_velocity_vector)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

import traceback
import sys
class CrossDistancePool:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(CrossDistancePool, cls).__new__(cls)
            cls._instance.lBodies = lBodyPool_Singleton()
            cls._instance.hBodies = hBodyPool_Singleton()
            cls._instance.distances = {}
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def update(self):
        self.distances = {}
        avg_hbody_count = []
        for lbody_idx in self.lBodies.bodies:
            for lbody2_idx in self.lBodies.bodies:
                key=(lbody_idx,lbody2_idx)
                key_alt = (lbody2_idx,lbody_idx)
                if key_alt not in self.distances:
                    distance = self.lBodies[lbody_idx].get_distance2entity_hard(self.lBodies[lbody2_idx])
                    self.distances[key] = distance
#==SPACE==#

            req_hbodies_idx = self.lBodies.get(lbody_idx).get_surrounding_hbodies_ids()
            avg_hbody_count.append(len(req_hbodies_idx))
            for hbody_idx in req_hbodies_idx:#ChunkController().get_active_hbodies(): #self.hBodies.bodies:
                if hbody_idx:
                    distance = self.lBodies[lbody_idx].get_distance2entity_hard(self.hBodies[hbody_idx])
                    key=(lbody_idx,hbody_idx)
                    self.distances[key] = distance
        PerformanceCollector().add("avg_hbody_count", np.mean(avg_hbody_count if avg_hbody_count else [0]))
#==SPACE==#

    def get(self, mark_1, mark_2):
        try:
            if mark_1==mark_2: return 0
            if self.distances == {}: self.update()
            if (mark_1, mark_2) in self.distances:
                return self.distances[(mark_1, mark_2)]
            return self.distances[(mark_2, mark_1)]
        except Exception as e:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            print(traceback.print_tb(exc_traceback))
        return None
#==SPACE==#

#==SPACE==#

#==SPACE==#

import numpy as np
from modules.physEngine.world_constants import WorldPhysConstants
#==SPACE==#

from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
#==SPACE==#

#==SPACE==#

#==SPACE==#

class lBodyPool_Singleton:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(lBodyPool_Singleton, cls).__new__(cls)
            cls._instance.bodies = {}
            cls._instance.bodies_description = {}
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def __getitem__(self, key):
        return self.bodies[key]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def clear(self):
        EntityIDGroupsController().clear()
        self.bodies = {}
#==SPACE==#

    def get(self,mark_id):
        if mark_id in self.bodies:
            return self.bodies[mark_id]
        return None
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def if_body_exists(self, body_id):
        return body_id in self.bodies
#==SPACE==#

    def add(self, body_object):
        lbody_id = body_object.mark_id
        self.bodies[lbody_id] = body_object
#==SPACE==#

#==SPACE==#

    def get_ships_ids(self):
        ids = []
        for k in self.bodies:
            body = self.bodies[k]
            if body.type=="ae_ship":
                ids.append(body.mark_id)
        return ids
#==SPACE==#

    def delete(self, body_id):
        if body_id in self.bodies:
            self.bodies.pop(body_id)
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

        for hbodi_id in hBodyPool_Singleton().bodies:
            hBodyPool_Singleton().bodies[hbodi_id].del_from_gwell(body_id)
        EntityIDGroupsController().remove(body_id)
#==SPACE==#

#==SPACE==#

    def iter_loop(self):
        self.bodies_description = {}
        self.stats = {}
#==SPACE==#

        tmp_t1 = datetime.now()
        for i in self.bodies:
            self.bodies[i].update_position()
#==SPACE==#

        tmp_t2 = datetime.now()
#==SPACE==#

        for i in self.bodies:
            self.bodies_description[i] = self.bodies[i].get_description()
        tmp_t3 = datetime.now()
#==SPACE==#

        PerformanceCollector().add("lBodyPool.iter_loop.update_position", get_dt_ms(tmp_t1, tmp_t2))
        PerformanceCollector().add("lBodyPool.iter_loop.get_description", get_dt_ms(tmp_t2, tmp_t3))
#==SPACE==#

    def update_description(self):
        self.bodies_description = {}
        for i in self.bodies:
            self.bodies_description[i] = self.bodies[i].get_description()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_bodies_description(self):
        return self.bodies_description
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
from modules.utils import Command, PerformanceCollector
import copy
#==SPACE==#

class hBodyPool_Singleton:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(hBodyPool_Singleton, cls).__new__(cls)
            cls._instance.bodies = {}
            cls._instance.gravity_well_linear_percentage = ConfigLoader().get("world.gravity_well_linear_percentage", float)
            cls._instance.realtime_update = True
            cls._instance.bodies_description = None
            cls._instance._index = {}
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_max_distance(self):
        distance = 0
        for body_idx in self.bodies:
            pos = self.bodies[body_idx].get_position_np()
            tmp_dist = np.linalg.norm(pos)
            if tmp_dist>distance:
                distance = tmp_dist
        return distance+self.bodies[body_idx].gravity_well_radius
#==SPACE==#

#==SPACE==#
        
    def proceed_command(self, command:Command):
        action = command.get_action()
        match action:
            case "set_realtime_update":
                self.realtime_update = command.get_params()["value"]
                self.bodies_description = self.get_live_description()
#==SPACE==#

            case "cache_static_lbodies":
                self.cache_static_lbodies()
#==SPACE==#

            case 'uncache_static_lbodies':
                self.uncache_static_lbodies()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def __getitem__(self, key):
        return self.bodies[key]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def __iter__(self):
        return iter(self.bodies)
#==SPACE==#

    def clear_index(self):
        self.index = {}
#==SPACE==#

#==SPACE==#

    def cache_static_lbodies(self):
        for body_idx in self.bodies:
            self.bodies[body_idx].cache_static_lbodies(force = True)
#==SPACE==#

#==SPACE==#

    def uncache_static_lbodies(self):
        for body_idx in self.bodies:
            self.bodies[body_idx].uncache_static_lbodies(force = True)
#==SPACE==#

#==SPACE==#

    @property
    def index(self):
        if not self._index:
            self.generate_index()
        return self._index
#==SPACE==#

#==SPACE==#

    @index.setter
    def index(self, value):
        self._index = value
#==SPACE==#

#==SPACE==#

    def get_index_assosiated_idx_list(self, idx):
        #return self.bodies
        try:
            return copy.deepcopy(self.index[idx])
        except Exception as e:
            pass
            #print("get_index_assosiated_idx_list", repr(e))
        return self.bodies
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def generate_index(self):
        self.clear_index()
        for body_idx in self.bodies:
            self.generate_index_for_single_body(body_idx)
        print("index generated")
#==SPACE==#

#==SPACE==#

    def generate_index_for_single_body(self, body_idx):
        tmp = []
        for body_idx2 in self.bodies:
                distance = self.bodies[body_idx].get_distance2entity_hard(self.bodies[body_idx2])
                gravity_connection_distance = self.bodies[body_idx].gravity_well_radius+self.bodies[body_idx2].gravity_well_radius
                if distance<gravity_connection_distance*2:
                    tmp.append(body_idx2)
                    if body_idx2 in self._index:
                        self._index[body_idx2].append(body_idx)
        self._index[body_idx] = tmp
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def export_descr(self):
        result = {}
        for body_idx in self.bodies:
            result[body_idx] = self.bodies[body_idx].export_descr()
        return result
#==SPACE==#

    def import_descr(self, json_descr):
        self.bodies = {}
        for k in json_descr:
            body = hBody(0,0,1,1)
            body.import_descr(json_descr[k])
            self.add(body)
        self.generate_index()
        self.update_description()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def add(self, hbody):
        self.bodies[hbody.mark_id] = hbody
        self.generate_index_for_single_body(hbody.mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def get(self, body_id):
        if body_id in self.bodies:
            return self.bodies[body_id]
        return None
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def delete(self, body_id):
        if body_id in self.bodies:
            self.bodies.pop(body_id)
        self.generate_index()
        self.update_description()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_gravity_affected_body(self, pos):
        for k in self.bodies:
            if self.bodies[k].is_position_in_gravity_well(pos):
                return self.bodies[k]
        return None
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def get_gravity_affected_body_idx(self, pos, last_hbody_idx = None):
        #если last_hbody_idx == None, вернет словарь всех тел
        #если нет - вернет список соседей
        list_idx = self.get_index_assosiated_idx_list(last_hbody_idx)
        for k in list_idx:
            if self.bodies[k].is_position_in_gravity_well(pos):
                return k
        #ес
#==SPACE==#

#==SPACE==#
                
        if last_hbody_idx:
            distance_to_last_hbody = np.linalg.norm(self.bodies[last_hbody_idx].get_position_np()-pos)
            last_hbody_gr = self.bodies[last_hbody_idx].gravity_well_radius
            if distance_to_last_hbody<last_hbody_gr+500:
                return last_hbody_idx
#==SPACE==#

#==SPACE==#
            
        #ультимативная штука
        last_hbody_idx = self.get_closest_hbody(pos)
        return last_hbody_idx
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

    def get_closest_hbody(self, pos):
        distance = 999999999999999999999999
        req_hbody_idx = None
        for hbody_idx in self.bodies:
            hb_pos = self.bodies[hbody_idx].get_position_np()
            tmp_dist = np.linalg.norm(pos-hb_pos)
            if tmp_dist<distance:
                distance = tmp_dist
                req_hbody_idx = hbody_idx
        return req_hbody_idx
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_single_gravity(self, position, mass, hbody_idx):
        if not hbody_idx: return np.zeros(2)
        dPos = self.bodies[hbody_idx].position-position
        gravity_well_radius = self.bodies[hbody_idx].gravity_well_radius
        r = max(np.linalg.norm(dPos),20)
        F = WorldPhysConstants().get_Gconst()*(mass*self.bodies[hbody_idx].mass)/(r*r)
#==SPACE==#

        distance_2_center = r/gravity_well_radius
        if self.gravity_well_linear_percentage<=distance_2_center<=1:
            F = F*((1-distance_2_center)/(1-self.gravity_well_linear_percentage))
#==SPACE==#

        Fproj = CalculationUtilites.get_projections(F, dPos)/mass
        return Fproj
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_summary_gravity(self, pos, mass, last_hbody_idx = None):
        list_idx = self.get_index_assosiated_idx_list(last_hbody_idx)
        summaryFproj = np.zeros(2)
        for k in list_idx:
            summaryFproj = summaryFproj+self.get_single_gravity(pos,mass,k)
        return summaryFproj
#==SPACE==#

    def get_bodies_positions(self):
        hBodies_dict = {}
        for i in self.bodies:
            hBodies_dict[i] = self.bodies[i].get_position()
        return hBodies_dict
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_live_description(self):
        hBodies_dict = {}
        for i in self.bodies:
            hBodies_dict[i] = self.bodies[i].get_description()
        return hBodies_dict
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def update_description(self):
        if not self.realtime_update:
            self.bodies_description = self.get_live_description()
#==SPACE==#

    def get_bodies_description(self):
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        if self.realtime_update:
            return self.get_live_description()
        else:
            if not self.bodies_description:
                self.update_description()
        return self.bodies_description
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def is_position_in_gravity_well(self, pos, hbody_idx):
        try:
            return self.bodies[hbody_idx].is_position_in_gravity_well(pos)
        except Exception as e:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            print(traceback.print_tb(exc_traceback))
            return False
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def clear(self):
        self.bodies = {}
        self.update_description()
        self.clear_index()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

    def get_uncached_hbodies_list(self):
        ships = EntityIDGroupsController().get("is_ships")
        hbodies_2_prepare = []
        for ship_id in ships:
            ship_body = lBodyPool_Singleton().get(ship_id)
            if ship_body.hbody_idx:
                hbodies_2_prepare.append(ship_body.hbody_idx)
            else:
                hbodies_2_prepare.append(ship_body.last_hbody_idx)
#==SPACE==#

        hbodies_2_prepare2 = []
        for hbodi_id in hbodies_2_prepare:
            if hbodi_id:
                new_bodies = self.get_index_assosiated_idx_list(hbodi_id)
                hbodies_2_prepare2 = hbodies_2_prepare2+new_bodies
#==SPACE==#

        return set(hbodies_2_prepare+hbodies_2_prepare2)
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def iter_loop(self):
        need_2_uncache = self.get_uncached_hbodies_list()
        a =len(self.bodies)
        for k in self.bodies:
            if k in need_2_uncache:
                self.bodies[k].uncache_static_lbodies()
            else:
                self.bodies[k].cache_static_lbodies()
            self.bodies[k].step()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

import math as m
class CalculationUtilites:
    hBodies= hBodyPool_Singleton()
    #проекция скаляра F на вектор
    def get_projections(F, vector):
        dx = vector[0]
        dy = vector[1]
        r = np.linalg.norm(vector)
        if r == 0: return np.array([0,0], dtype=np.float32)
        Fx = F*dx/r
        Fy = F*dy/r
        return np.array([Fx,Fy], dtype=np.float32)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    #
    def get_stable_velocity(pos, vec = np.zeros(2)):
        hbody = CalculationUtilites.hBodies.get_gravity_affected_body(pos)
        if not hbody: return np.array([0,0])
        mass = hbody.mass
        radius = pos-hbody.position
        radius_scalar = max(1,np.linalg.norm(radius))
        tangent = CalculationUtilites.rotate_vector(radius,90)
        V_scalar = m.sqrt(WorldPhysConstants().get_Gconst()*mass/radius_scalar)
        V_vector = CalculationUtilites.get_projections(V_scalar, tangent)
        if np.linalg.norm(vec)!=0:
            cos_alpha = CalculationUtilites.get_cosangle_between(V_vector, vec)
            if cos_alpha<0:
                V_vector = V_vector*-1
        return V_vector
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def rotate_vecto_rad(vector, angler):
        x = vector[0]
        y = vector[1]
        newx = x*m.cos(angler) - y*m.sin(angler)
        newy = x*m.sin(angler) + y*m.cos(angler)
        return np.array([newx, newy])
#==SPACE==#

    def rotate_vector(vector, angle):
        x = vector[0]
        y = vector[1]
        angler = angle*m.pi/180
        newx = x*m.cos(angler) - y*m.sin(angler)
        newy = x*m.sin(angler) + y*m.cos(angler)
        return np.array([newx, newy])
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_cosangle_between(vector1, vector2):
        cos_alpha = np.dot(vector1, vector2)/(np.linalg.norm(vector1)*np.linalg.norm(vector2))
        return cos_alpha
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_radangle_between(vector1, vector2):
        cos_alpha = CalculationUtilites.get_cosangle_between(vector1, vector2)
        alpha_rad = np.arccos(cos_alpha)
        vector3_ort = CalculationUtilites.rotate_vector(vector2, 90)
        cos_alpha_ort = CalculationUtilites.get_cosangle_between(vector1, vector3_ort)
        if cos_alpha_ort<0:
                alpha_rad = -alpha_rad
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        return alpha_rad
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_abs_angle_degrees_from_zero(vector1):
        vector2 = np.array([1,0])
        cos_alpha = CalculationUtilites.get_cosangle_between(vector1, vector2)
        alpha_rad = np.arccos(cos_alpha)
        vector3_ort = CalculationUtilites.rotate_vector(vector2, 90)
        cos_alpha_ort = CalculationUtilites.get_cosangle_between(vector1, vector3_ort)
        if cos_alpha_ort<0:
                alpha_rad = 3.14*2-alpha_rad
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        return alpha_rad*180/3.14
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def degress2rads(value):
        return value*3.14/180
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def is_in_sector(value, arc1, arc2):
        arc1 = (arc1+360*2)%360
        arc2 = (arc2+360*2)%360
        value = (value+360*2)%360
        if arc1<arc2:
            arc2 = arc2-360
        if arc1<value:
            value = value-360
        return arc2<value<arc1
#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_intersection_for_2_circles(pos1, rad1, pos2, rad2):
        #https://algolist.ru/maths/geom/intersect/circlecircle2d.php#:~:text=%2D2ax%2D2by%20%3D%20R2,%2D%20a2%20%2D%20b2.&text=ax%2Bby%3DC%2C%20%D0%B3%D0%B4%D0%B5,%D0%A1%20%2D%20%D0%BD%D0%BE%D0%B2%D0%BE%D0%B5%20%D0%BE%D0%B1%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%B0.
        d = np.linalg.norm(pos1-pos2)
        if d == 0:
            return None
        a = (rad1**2 - rad2**2 + d**2)/(2*d)
        discr = rad1**2 - a**2
        if discr<0:
            return None
        h = math.sqrt(discr)
        pos3 = pos1+a*(pos2-pos1)/d
        p4_1_x = pos3[0]+h*(pos2[1]-pos1[1])/d
        p4_1_y = pos3[1]-h*(pos2[0]-pos1[0])/d
#==SPACE==#

        p4_2_x = pos3[0]-h*(pos2[1]-pos1[1])/d
        p4_2_y = pos3[1]+h*(pos2[0]-pos1[0])/d
#==SPACE==#

        return np.array([p4_1_x,p4_1_y]), np.array([p4_2_x,p4_2_y])
#==SPACE==#

#==SPACE==#

class hBodyStatsCalculator:
    def get_stats(body_descr):
        ConfigLoader().update()
        results = {}
        mass = body_descr["mass"]
        Rgr = body_descr["gr"]
        Rcr = body_descr["critical_r"]
        Rmd = (Rgr+Rcr)/2
        for rname, rval in [
            ("_Rcr",Rcr),
            ("_Rmd",Rmd),
            ("_Rmx",Rgr),
        ]:
            results["V"+rname] = round(hBodyStatsCalculator.get_V(mass,rval),2)
            results["T"+rname] = round(hBodyStatsCalculator.get_T(mass,rval),2)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        results["delV:Rcr-Rmd"] = hBodyStatsCalculator.get_delV(mass,Rcr,Rmd)
        results["delV:Rmd-Rmx"] = hBodyStatsCalculator.get_delV(mass,Rmd,Rgr)
        results["delV:Rcr-Rmx"] = hBodyStatsCalculator.get_delV(mass,Rcr,Rgr)
        return results
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_V(m, r):
        G = ConfigLoader().get("world.gravity_constant", float)
        V = math.sqrt((m*G)/r)
        return V
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_T(m,r):
        v = hBodyStatsCalculator.get_V(m,r)*WorldPhysConstants().get_real2sim_timescale()
        T = 2*3.1415*r/v
        return T
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_delV(m, r1, r2):
        r = r2/r1
        v = hBodyStatsCalculator.get_V(m,r1)
        delV1 = round(v*(math.sqrt(2*r/(r+1))-1),2)
        delV2 = round((v/math.sqrt(r))*(1-math.sqrt(2/(r+1))),2)
        return f"{delV1}, {delV2}, {round(delV1+delV2,2)}"

###===###.\back01\modules\physEngine\entity_id_groups_controller.py
class EntityIDGroupsController:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(EntityIDGroupsController, cls).__new__(cls)
            cls._instance.categories = {
                "is_station": [],
                "radar_detectable": [],
                "id_labels_detectable": [],
                "is_ships": [],
                "interactable": [],
                "stationary_orbit":[],
            }
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get(self, category):
        if category not in self.categories:
            if category == "is_station":
                self.categories[category] = []
        return self.categories[category]
#==SPACE==#

    def add(self, mark_id, categories):
        for category in categories:
            if category in self.categories:
                if mark_id not in self.categories[category]:
                    self.categories[category].append(mark_id)
            else:
                self.categories[category] = [mark_id]
#==SPACE==#

#==SPACE==#

    def remove(self, mark_id):
        for category in self.categories:
            if mark_id in self.categories[category]:
                self.categories[category].remove(mark_id)
#==SPACE==#

    def clear(self):
        self.categories = {
                "radar_detectable": [],
                "id_labels_detectable": [],
                "is_ships": [],
                "interactable": [],
                "stationary_orbit":[],
            }

###===###.\back01\modules\physEngine\event_system.py
#==SPACE==#

from modules.ship.ship import ShipPool_Singleton
from modules.physEngine.core import lBodyPool_Singleton
from modules.utils import Command, CommandQueue, ConfigLoader
#==SPACE==#

#==SPACE==#

def get_entity_from_Pools(mark_id, pool_list):
    for pool in pool_list:
        entity = pool.get(mark_id)
        if entity: return entity
    return None
#==SPACE==#

#==SPACE==#

class GlobalEventSystem:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(GlobalEventSystem, cls).__new__(cls)
            cls._instance.cShips = ShipPool_Singleton()
            cls._instance.lBodies = lBodyPool_Singleton()
#==SPACE==#

        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def takes_damage(self, mark_id, damage_value, damage_type):
        target = get_entity_from_Pools(mark_id, [self.cShips, self.lBodies])
        if not target: return
        if hasattr(target, "takes_damage"):
            target.takes_damage(damage_value, damage_type)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
    def add_resource(self, target_id,resource_name, resource_amount):
        target = get_entity_from_Pools(target_id, [self.cShips, self.lBodies])
        if not target: return
        if hasattr(target, "gain_resource"):
            target.gain_resource(resource_name,resource_amount)
#==SPACE==#

#==SPACE==#

    def hBodyCollision(self, target_id):
        phys_target = get_entity_from_Pools(target_id, [self.lBodies])
        if not phys_target: return
#==SPACE==#

        phys_target.stabilize_orbit(offset=5)
#==SPACE==#

        target = get_entity_from_Pools(target_id, [self.cShips, self.lBodies])
        damage_value = ConfigLoader().get("damage.hbody_collision_damage", float)
        if hasattr(target, "takes_damage"):
            target.takes_damage(damage_value, "collision")
#==SPACE==#

#==SPACE==#

#==SPACE==#
                

###===###.\back01\modules\physEngine\frame_counter.py

###===###.\back01\modules\physEngine\hb_entities.py
from modules.physEngine.core import hBody, hBodyPool_Singleton
from modules.physEngine.world_constants import WorldPhysConstants
from modules.physEngine.triggers.collector import TriggerQueue
from modules.utils import ConfigLoader
from modules.physEngine.solar_flare.solar_flar_defendzone import SolarFlareDefendZone
#==SPACE==#

class ResourceAsteroid(hBody):
    def __init__(self, x, y, r=100, m=10):
        super().__init__(x,y,r,m)
        self.mining_radius = self.gravity_well_radius #ConfigLoader().get("world.mining_r_percentage", float)*
        self.marker_type = self.__class__.__name__ # "resource_asteroid"
        self.radar_levels = [
            (0, "resource"),
        ]
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_description(self,requester_id=None):
        result = super().get_description(requester_id)
        result['mining_radius'] = self.mining_radius
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def put_description(self, json_descr, forced=False):
        super().put_description(json_descr, forced)
        self.mining_radius = ConfigLoader().get("world.mining_r_percentage", float)*self.gravity_well_radius
        if forced:
            self.mining_radius = json_descr['mining_radius']
#==SPACE==#

    def add_in_gwell(self, mark_id):
        super().add_in_gwell(mark_id)
        SolarFlareDefendZone().add(mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def del_from_gwell(self, mark_id):
        super().del_from_gwell(mark_id)
        SolarFlareDefendZone().remove(mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def step(self):
        super().step()
#==SPACE==#

    #def step(self):
    # bodies_ids = self.get_entities_ids_list_in_range(self.lBodies.bodies, self.mining_radius, False)
    # for body_id in bodies_ids:
    #  TriggerQueue().add("collisionIntohBody", self.mark_id, {"target":body_id})
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

class WormHole(hBody):
    def __init__(self, x, y, r=100, m=10):
        super().__init__(x,y,r,m)
        self.marker_type = self.__class__.__name__ # "resource_asteroid"
        self.radar_levels = [
            (2, "hbody"), #invisible on radar
        ]
        self.type = "WormHole"
        self.mark_id = "WormHole"
        self.critical_r = 1
#==SPACE==#

    def step(self):
        pass
#==SPACE==#

    def get_description(self, requester_id=None):
        res = super().get_description(requester_id)
        res.pop("critical_r")
        return res

###===###.\back01\modules\physEngine\marks_collector.py
class MarksCollector:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(MarksCollector, cls).__new__(cls)
            cls._instance.data = {}
#==SPACE==#

        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def add(self, category, mark_id):
        if category not in self.data: self.data[category]=[]
        self.data[category].append(mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get(self,category):
        return self.data[category]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def clear(self):
        self.data = {}
#==SPACE==#

    def remove(self, mark_id):
        for category in self.data:
            self.data[category].remove(mark_id)

###===###.\back01\modules\physEngine\pools.py

###===###.\back01\modules\physEngine\predictor.py
import numpy as np
import multiprocessing as mp
from modules.physEngine.core import hBodyPool_Singleton
from modules.physEngine.core import TrajectoryCalculator, hBody
from modules.physEngine.world_constants import WorldPhysConstants
from modules.utils import ConfigLoader, Command
import time
import os
#==SPACE==#

#==SPACE==#

class TrajectoryPredictor_controller:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(TrajectoryPredictor_controller, cls).__new__(cls)
            try:
                ctx_manager = mp.Manager()
                cls._instance.shared_dict = ctx_manager.dict()
                cls._instance.predictors = {}
                cls._instance.control_queues = {}
                cls._instance.task_counter = {}
                cls._instance.hBodies = hBodyPool_Singleton()
                cls._instance.predictors_performance = []
                cls._instance.predictors_performance_length = 300
            except Exception as e:
                print(repr(e))
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def is_online(self):
        return self.predictors != {}
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def add_predictor_performance_timestamp(self, timestamp):
        self.predictors_performance.append(timestamp)
        if len(self.predictors_performance)>self.predictors_performance_length:
            self.predictors_performance = self.predictors_performance[-self.predictors_performance_length:]
#==SPACE==#

    def get_predictor_performance_statistics(self):
        if self.predictors_performance==[]:
            return 0.0
        return np.mean(self.predictors_performance)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_free_predictor(self):
        predictor_key = min(self.task_counter, key=self.task_counter.get)
        return predictor_key
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_physics(self, params):
        for key in self.control_queues:
            self.control_queues[key].put({"type":"set_physics",
                                            "Gconst":params["Gconst"],
                                            "timestep":params["timestep"]})
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
    def update_physics(self):
        for key in self.control_queues:
            self.control_queues[key].put({"type":"set_physics",
                                            "Gconst":WorldPhysConstants().get_Gconst(),
                                            "timestep":WorldPhysConstants().get_timestep()})
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def prepare_for_predictor_injection(self):
        in_queue = mp.Queue()
        key = len(self.predictors)
        self.control_queues[key] = in_queue
        self.task_counter[key] = 0
        return key
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def launch_new_predictor(self):
        print("launch_new_predictor", os.getpid())
        in_queue = mp.Queue()
        mp.set_start_method('spawn')
        predictor_process = mp.Process(target=run_predictor_instance, args=(in_queue,self.shared_dict, self.hBodies))
        key = len(self.predictors)
        self.predictors[key] = predictor_process
        self.predictors[key].start()
        self.control_queues[key] = in_queue
        self.task_counter[key] = 0
#==SPACE==#

    def stop_all_predictors(self):
        predictors_keys = list(self.predictors.keys())
        for key in predictors_keys:
            self.stop_predictor(key)
#==SPACE==#

    def stop_predictor(self, key):
        self.control_queues[key].put({"type":"stop"})
        time.sleep(1)
        self.predictors[key].join()
        self.predictors.pop(key)
        self.control_queues.pop(key)
        self.task_counter.pop(key)
#==SPACE==#

    def proceed_command(self, cmd:Command):
        action = cmd.get_action()
        params = cmd.get_params()
        match action:
            case 'terminate_predictor_process':
                    predictors_keys = list(self.predictors.keys())
                    if len(predictors_keys)>0:
                        self.stop_predictor(predictors_keys[0])
#==SPACE==#

            case 'add_predictor_process':
                run_predictor_process()
#==SPACE==#

    def update_hbodies_location(self):
        #launch_new_TrajectoryPredictor_controller()
        #self.stop_all_predictors()
        #self.launch_new_predictor()
        #time.sleep(1)
        #self.launch_new_predictor()
        #self.launch_new_predictor()
        #self.update_physics()
        bodies_descr = self.hBodies.export_descr()
        predictors_keys = list(self.predictors.keys())
        for key in predictors_keys:
            self.control_queues[key].put({"type":"update_hbodies",
                                            "data":bodies_descr})
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def login(self, mark):
        try:
            self.shared_dict[f"{mark}_ready"] = True
            self.shared_dict[f"{mark}_predictions"] = []
            self.shared_dict[f"{mark}_time"]= 0
        except Exception as e:
            print(repr(e))
#==SPACE==#

    def logout(self, mark):
        if f"{mark}_ready" in self.shared_dict:
            self.shared_dict.pop(f"{mark}_ready")
        if f"{mark}_predictions" in self.shared_dict:
            self.shared_dict.pop(f"{mark}_predictions")
        if f"{mark}_time" in self.shared_dict:
            self.shared_dict.pop(f"{mark}_time")
#==SPACE==#

    def upload_task(self, mark, params):
        if not self.is_online(): return False
        if self.shared_dict[f"{mark}_ready"]:
            key = self.get_free_predictor()
            self.control_queues[key].put({"type":"put",
                                            "mark":mark,
                                            "params":params})
            self.task_counter[key] = self.task_counter[key]+1
            self.shared_dict[f"{mark}_ready"] = False
            return True
        else:
            return False
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
    def get_prediction(self,mark):
        if f"{mark}_predictions" in self.shared_dict:
            self.add_predictor_performance_timestamp(self.shared_dict[f"{mark}_time"])
            return self.shared_dict[f"{mark}_predictions"]
        else:
            print("no key:",mark)
            return []
#==SPACE==#

#==SPACE==#

def run_predictor_instance(in_queue, out_dictionary, hBodies):
        predictor = TrajectoryPredictor(in_queue, out_dictionary, hBodies)
        predictor.start()
#==SPACE==#

#==SPACE==#

#==SPACE==#
    
def run_predictor_process():
    predictor_controller = TrajectoryPredictor_controller()
    key = predictor_controller.prepare_for_predictor_injection()
    predictor_process = mp.Process(target=run_predictor_instance, args=(predictor_controller.control_queues[key],predictor_controller.shared_dict, hBodyPool_Singleton()))
    predictor_process.start()
    predictor_controller.predictors[key] = predictor_process
#==SPACE==#

def launch_new_TrajectoryPredictor_controller():
    predictor_controller = TrajectoryPredictor_controller()
    predictor_controller.stop_all_predictors()
    pass
    run_predictor_process()
    #run_predictor_process()
    #run_predictor_process()
    #run_predictor_process()
    #predictor_controller.launch_new_predictor()
    #predictor_controller.launch_new_predictor()
    #predictor_controller.launch_new_predictor()
#==SPACE==#

#==SPACE==#

# получает на вход обновление скорости в моменте,
# возвращает в контекстный словарь вектор из предсказаний с
# N+1й точки.
from datetime import datetime, timedelta
import traceback
class TrajectoryPredictor(TrajectoryCalculator):
    def __init__(self, in_queue, out_dictionary, hBodies):
        self.timestep = WorldPhysConstants().get_timestep()
        super().__init__(np.zeros(2), np.zeros(2))
        self.in_queue = in_queue
        self.out_dictionary = out_dictionary
        self.hBodies = hBodies
        #self.prediction_count_maxlimit = 250
        self._memset_grid(self.prediction_count_maxlimit)
        self.debug_output = False
        self.is_predictor = True
#==SPACE==#

    def get_timestep(self):
        return self.timestep
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_predictors_depth(self, depth):
        try:
            real_depth = depth*WorldPhysConstants().get_real2sim_timescale()
            self.timestep = WorldPhysConstants().get_timestep()
#==SPACE==#

            prediction_counts = int(real_depth//self.timestep)
            if prediction_counts > self.prediction_count_maxlimit:
                #pass
                self.timestep = real_depth/self.prediction_count_maxlimit
            self.predictions_count = min(self.prediction_count_maxlimit, prediction_counts)
            #self.predictions_count = self.prediction_count_maxlimit
#==SPACE==#

        except Exception as e:
            print(e)
#==SPACE==#

#==SPACE==#

    #за каждое полученное сообщение в очереди, он считает траекторию с заданных координат
    #каждое сообщение промаркировано mark_id. Пока один запрос не обработан, не стоит
    #присылать другой с тем же mark_id
    def start(self):
        try:
            not_stopped = True
            while not_stopped:
                if not self.in_queue.empty():
                    command = self.in_queue.get()
#==SPACE==#

                    match command["type"]:
                        case "put":
#==SPACE==#

#==SPACE==#

#==SPACE==#
                                
                            mark = command["mark"]
                            self.mark_id = mark
                            self.last_hbody_idx = command["params"]["last_hbody_idx"]
                            self.hbody_idx = command["params"]["hbody_idx"]
                            pos = np.array(command["params"]["pos"])
                            vel = np.array(command["params"]["vel"])
                            self.mass = command["params"]["mass"]
                            depth = command["params"]["depth"]#*ConfigLoader().get("world.predictor_timedelay", float)
                            timestep = datetime.now()
                            self.set_predictors_depth(depth)
                            self.set_position_and_velocity(pos,vel)
                            dt = datetime.now()-timestep
                            preds = self.get_prediction()
#==SPACE==#

                            self.out_dictionary[f"{mark}_predictions"] = preds #выгрузка результатов
                            self.out_dictionary[f"{mark}_ready"] = True #освобождение мьютекса для следующей итерации
                            self.out_dictionary[f"{mark}_time"] = dt.microseconds/1000000
#==SPACE==#

#==SPACE==#

#==SPACE==#
                                
#==SPACE==#

                        case "stop":
                            print("TrajectoryPredictor termination")
                            not_stopped = False
                            break
#==SPACE==#

                        case 'set_physics':
                            WorldPhysConstants().set_Gconst(command["Gconst"])
                            WorldPhysConstants().set_timestep(command["timestep"])
#==SPACE==#

                        case "update_hbodies":
                            descr = command["data"]
                            self.hBodies.import_descr(descr)
#==SPACE==#

                #self.generate_prediction()
        except Exception as e:
            print(repr(e))
            print(traceback.format_exc())
#==SPACE==#

    def get_prediction(self):
        return self.positions[self.predictions_count::-15].tolist()[::-1]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def set_position_and_velocity(self, pos, vel):
        self.positions[0] = pos
        self.velocities[0] = vel
        for i in range(1,self.predictions_count):
            self.next_step(i)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#


###===###.\back01\modules\physEngine\quest_events.py
from modules.utils import Command
#==SPACE==#

class QuestEvent:
    def __init__(self):
        self.description = ""
        self.trigger = None
#==SPACE==#

    def match(trigger):
        pass
#==SPACE==#

class QuessEventsController:
    __instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(QuessEventsController, cls).__new__(cls)
            cls._instance.quest_events = []
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_state(self):
        pass
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def proceed_command(self, cmd: Command):
        action = cmd.get_action()
        params = cmd.get_params()
        match action:
            case "add_quest_event": self.add()
#==SPACE==#

    def add(self, quest_event_descr):
        pass
#==SPACE==#

    def get_state(self):
        pass
#==SPACE==#

    def check_quest_event(trigger):
#==SPACE==#

        pass

###===###.\back01\modules\physEngine\world_constants.py
from modules.utils import ConfigLoader
class WorldPhysConstants:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(WorldPhysConstants, cls).__new__(cls)
            cls._instance.Gconst = ConfigLoader().get("world.gravity_constant", float)
            #cls._instance.timestep = 0.5
            cls._instance.timestep = 0.03
            cls._instance.real_timestep = 0.03
            cls._instance.frame_counter = 0
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def set_Gconst(self, value):
        self.Gconst = value
#==SPACE==#

    def get_Gconst(self):
        return self.Gconst
#==SPACE==#

    def set_timestep(self, value):
        self.timestep = value
#==SPACE==#

    def get_timestep(self):
        return self.timestep
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_real_timestep(self):
        return self.real_timestep
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_ticks_per_second(self):
        return 1.0/self.real_timestep
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_ticks_in_seconds(self, seconds):
        return seconds/self.real_timestep
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_real2sim_timescale(self):
        return self.timestep/self.real_timestep
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_onetick_step(self, summary_value, summary_realtime):
        step_per_sec = summary_value/summary_realtime
        step_per_tick = step_per_sec/(1/self.real_timestep)
        return step_per_tick
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def next_step(self):
        self.frame_counter = self.frame_counter+1
#==SPACE==#

    def current_frame(self):
        return self.frame_counter
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\modules\physEngine\interactable_objects\container.py
from modules.physEngine.basic_objects import dynamicBody, lBody
from datetime import datetime, timedelta
from modules.physEngine.core import CalculationUtilites
import numpy as np
from modules.physEngine.triggers.collector import TriggerQueue
#==SPACE==#

from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
from modules.physEngine.basic_objects import staticBody
#==SPACE==#

class intact_Basic(staticBody, dynamicBody):
    def __init__(self, x,y, mark_id = None):
        staticBody.__init__(self)
        self.manual_init()
        dynamicBody.__init__(self, x,y, mark_id)
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#
            
        self.set_marker_type("interactable_object")
        EntityIDGroupsController().add(self.mark_id, ["interactable"])
    def interact(self):
        pass
#==SPACE==#

#==SPACE==#

    def get_interact_description(self):
        return ""
#==SPACE==#

    def self_destruct(self):
        super().self_destruct()
        EntityIDGroupsController().remove(self.mark_id)
#==SPACE==#

class intact_Container(intact_Basic):
    def __init__(self, x,y, mark_id = None):
        super().__init__(x,y, mark_id)
        self.storage = {
#==SPACE==#

        }
        for name in ["metal"]:
            self.storage[name]=1
#==SPACE==#

    def get_description(self, requester_id=None):
        descr = super().get_description(requester_id)
        for item in self.storage:
            descr[item] = self.storage[item]
        return descr
#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_interact_description(self):
        result = f"get "+str(self.storage["metal"])+" metal"
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def put_description(self, descr, foced):
        for item in self.storage:
            if item in descr:
                self.storage[item] = descr[item]
#==SPACE==#

#==SPACE==#

    def interact(self, interactor_id):
        for item in self.storage:
            TriggerQueue().add("addresource", self.mark_id, {
                        "target":interactor_id,
                        "resource_name":item,
                        "resource_amount":self.storage[item],
                        })
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        self.self_destruct()
#==SPACE==#

#==SPACE==#

#==SPACE==#

class ShipDebris(intact_Container):
    def __init__(self, x,y, mark_id = None):
        super().__init__(x,y, mark_id)
        self.set_marker_type("ShipDebris")
        self.storage["metal"]=500
        if mark_id == "Nuestra Bien[debris]":
            self.storage["metal"]=5000
        EntityIDGroupsController().add(self.mark_id, ["id_labels_detectable"])
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def self_destruct(self):
        super().self_destruct()
        EntityIDGroupsController().remove(self.mark_id)
#==SPACE==#

    def interact(self, interactor_id):
        for item in self.storage:
            TriggerQueue().add("addresource", self.mark_id, {
                        "target":interactor_id,
                        "resource_name":item,
                        "resource_amount":self.storage[item],
                        })
#==SPACE==#

#==SPACE==#

        if self.mark_id != "Nuestra Bien[debris]":
            self.self_destruct()
#==SPACE==#

#==SPACE==#

class SpaceStationDebris(intact_Container):
    def __init__(self, x,y, mark_id = None):
        super().__init__(x,y, mark_id)
        self.set_marker_type("SpaceStationDebris")
        for name in ["metal"]:
            self.storage[name]=1000
        EntityIDGroupsController().add(self.mark_id, ["id_labels_detectable"])
#==SPACE==#

    def get_surrounding_hbodies_ids(self):
        return [self.hbody_idx]
#==SPACE==#

    def self_destruct(self):
        super().self_destruct()
        EntityIDGroupsController().remove(self.mark_id)

###===###.\back01\modules\physEngine\projectiles\drones.py
from datetime import timedelta, datetime
import numpy as np
from modules.physEngine.projectiles.projectiles_core import pjtl_Basic
from modules.physEngine.core import CalculationUtilites
from modules.physEngine.triggers.collector import TriggerQueue
#==SPACE==#

#==SPACE==#

class io_Drone(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.set_marker_type(self.__class__.__name__)# "io_Drone"
        self.resource_storage = {}
        self.set_predictor_state(True)
#==SPACE==#

#==SPACE==#

    def get_params_template(self):
        return {
            'prediction_depth':[5, 60, 1, 20]
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_params(self, params):
        if 'prediction_depth' in params:
            self.predictor_depth = float(params["prediction_depth"])
            self.upload_state_to_predictor()
#==SPACE==#

    def get_description(self, requester_id=None):
        status = super().get_description(requester_id)
        status["type"] = "io_Drone"
        return status
#==SPACE==#

    def gain_resource(self,resource_name,resource_amount):
        if self.status == "launched":
            self.status = "at_work"
            self.stabilize_orbit(offset=-5)
            self.predictor_controller.logout(self.mark_id)
#==SPACE==#

        if resource_name not in self.resource_storage:
            self.resource_storage[resource_name]=0
        self.resource_storage[resource_name] = self.resource_storage[resource_name]+resource_amount
#==SPACE==#

#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
#==SPACE==#

        elif self.status == "at_work":
            self.update_predictions()
#==SPACE==#

#==SPACE==#

    def interact(self, interactor_id):
        if self.status == "at_work":
            if interactor_id != self.master_id: self.detonate()
            for resource_name in self.resource_storage:
                TriggerQueue().add("addresource", self.mark_id,{
                            "target":interactor_id,
                            "resource_name":resource_name,
                            "resource_amount":self.resource_storage[resource_name],
                            })
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
            TriggerQueue().add("addresource", self.mark_id,{
                            "target":interactor_id,
                            "resource_name":"io_Drone",
                            "resource_amount":1,
                            })
#==SPACE==#

#==SPACE==#

            self.self_destruct()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\modules\physEngine\projectiles\explosives.py
from datetime import timedelta, datetime
import numpy as np
from modules.physEngine.projectiles.projectiles_core import pjtl_Basic
from modules.physEngine.core import CalculationUtilites
from modules.utils import ConfigLoader
from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
from modules.physEngine.world_constants import WorldPhysConstants
import random
#==SPACE==#

class pjtl_TimedExplosive(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.predictor_depth = 5
        self.ttl = timedelta(seconds=self.predictor_depth)
        self.launch_timestamp = 5
        self.explosion_radius = ConfigLoader().get("projectile_params.pjtl_timedexplosive_exprad", float)
        self.velocity_penalty = ConfigLoader().get("projectile_params.pjtl_timedexplosive_velpenalty", float)
#==SPACE==#

    def set_params(self, params):
        if 'detonation_time' in params:
            self.predictor_depth = float(params["detonation_time"])
            self.ttl = timedelta(seconds=self.predictor_depth)
            self.upload_state_to_predictor()
#==SPACE==#

    def get_params_template(self):
        return {
            'detonation_time':[0,10,1,5]
        }
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
            if (datetime.now() - self.launch_timestamp)>self.ttl:
                self.detonate()
#==SPACE==#

#==SPACE==#

#==SPACE==#

class pjtl_TriggerExplosive(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.predictor_depth = ConfigLoader().get("projectile_params.pjtl_triggerexplosive_ttl", float)
        self.launch_timestamp = None
        self.ttl = timedelta(seconds=self.predictor_depth)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.explosion_radius = ConfigLoader().get("projectile_params.pjtl_triggerexplosive_exprad", float)
        self.activation_radius = ConfigLoader().get("projectile_params.pjtl_triggerexplosive_exprad", float)
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
            if (datetime.now() - self.launch_timestamp)>self.ttl:
                self.detonate()
#==SPACE==#

            reachable_bodies = self.get_entities_ids_list_in_range(self.lBodies.bodies, self.activation_radius, False)
            if len(reachable_bodies)!=0:
                if self.master_id in reachable_bodies:
                    return
                for mark in reachable_bodies:
                    if hasattr(self.lBodies[mark], "master_id"):
                        if self.lBodies[mark].master_id != self.master_id:
                            self.detonate()
                    else:
                        self.detonate()
#==SPACE==#

#==SPACE==#

#==SPACE==#

class pjtl_TimedTorpedo(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.predictor_depth = 5
        self.ttl = timedelta(seconds=self.predictor_depth)
        self.launch_timestamp = 5
        self.explosion_radius = ConfigLoader().get("projectile_params.pjtl_timedtorpedo_exprad", float)
        self.velocity_penalty = ConfigLoader().get("projectile_params.pjtl_timedtorpedo_velpenalty", float)
#==SPACE==#

    def set_params(self, params):
        if 'detonation_time' in params:
            self.predictor_depth = float(params["detonation_time"])
            self.ttl = timedelta(seconds=self.predictor_depth)
            self.upload_state_to_predictor()
#==SPACE==#

    def get_params_template(self):
        return {
            'detonation_time':[0,60,1,5]
        }
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
            if (datetime.now() - self.launch_timestamp)>self.ttl:
                self.detonate()
#==SPACE==#

#==SPACE==#

#==SPACE==#

class pjtl_HomingLRMissile(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.predictor_depth = 10
#==SPACE==#

        self.fly_time = timedelta(seconds=self.predictor_depth)
        self.launch_timestamp = None
        self.ttl = timedelta(seconds=ConfigLoader().get("projectile_params.pjtl_HomingLRMissile_ttl", float))
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.activation_delay = timedelta(seconds=15)
#==SPACE==#

        self.velocity_penalty = ConfigLoader().get("projectile_params.pjtl_HomingLRMissile_velpenalty", float)
        self.detection_radius = ConfigLoader().get("projectile_params.pjtl_HomingLRMissile_targetdetectionrange", float)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.explosion_radius = ConfigLoader().get("projectile_params.pjtl_HomingLRMissile_exprad", float)
        self.activation_radius = ConfigLoader().get("projectile_params.pjtl_HomingLRMissile_expactrad", float)
#==SPACE==#

        self.locked_target = None
#==SPACE==#

        self.initial_speed = ConfigLoader().get("projectile_params.pjtl_HomingLRMissile_guidance_speed", float)
        self.acceleration = ConfigLoader().get("projectile_params.pjtl_HomingLRMissile_guidance_acceleration", float)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def set_params(self, params):
        if 'activation_time' in params:
            self.predictor_depth = float(params["activation_time"])
            self.fly_time = timedelta(seconds=self.predictor_depth)
            self.upload_state_to_predictor()
#==SPACE==#

    def get_params_template(self):
        return {
            'activation_time':[10,90,1,5]
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_description(self, requester_id=None):
        res = super().get_description(requester_id)
        res['explosion_radius'] = self.detection_radius
        return res
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

        elif self.status == "launched":
            self.update_predictions()
            if (datetime.now() - self.launch_timestamp)>self.activation_delay:
                self.status = "activated"
                self.launch_timestamp = datetime.now()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                        
#==SPACE==#

        elif self.status == "activated":
            if not self.locked_target:
                targetable_ids = self.get_entities_ids_from_list_in_range(RadarDetectionEntitiesController().get(), self.detection_radius, False)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
                if self.master_id in targetable_ids:
                    targetable_ids.remove(self.master_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                        
                if targetable_ids:
                    self.locked_target = random.choice(targetable_ids)
            else:
                target_pos = self.lBodies[self.locked_target].get_position_np()
                vector = target_pos-self.get_position_np()
                acceleration = self.get_acceleration_gravity(self.positions[1])+CalculationUtilites.get_projections(self.acceleration, vector)
                self.velocities[2]=CalculationUtilites.get_projections(self.initial_speed, vector)+WorldPhysConstants().get_timestep()*acceleration
            self.update_predictions()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

            reachable_bodies = self.get_entities_ids_list_in_range(self.lBodies.bodies, self.activation_radius, False)
            if len(reachable_bodies)!=0:
                self.detonate()
#==SPACE==#

            if (datetime.now() - self.launch_timestamp)>self.fly_time:
                self.detonate()

###===###.\back01\modules\physEngine\projectiles\mine.py
from datetime import timedelta, datetime
from modules.physEngine.projectiles.projectiles_core import pjtl_Basic
from modules.physEngine.core import CalculationUtilites
from modules.utils import ConfigLoader
import numpy as np
#==SPACE==#

class pjtl_Mine(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.activation_radius = ConfigLoader().get("projectile_params.pjtl_mine_exprad", float)
        self.explosion_radius = ConfigLoader().get("projectile_params.pjtl_mine_exprad", float)
        self.velocity_penalty = ConfigLoader().get("projectile_params.pjtl_mine_velpenalty", float)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def get_params_template(self):
        return {
            'prediction_depth':[5, 60, 1, 20]
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_params(self, params):
        if 'prediction_depth' in params:
            self.predictor_depth = float(params["prediction_depth"])
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
            reachable_bodies = self.get_entities_ids_list_in_range(self.lBodies.bodies, self.activation_radius, False)
            if len(reachable_bodies)!=0:
                if self.master_id in reachable_bodies: return
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
                for mark in reachable_bodies:
                    if not self.lBodies[mark].is_detectable: continue
                    if hasattr(self.lBodies[mark], "master_id"):
                        if self.lBodies[mark].master_id != self.master_id:
                            self.detonate()
                    else:
                        self.detonate()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\modules\physEngine\projectiles\mine_master.py
from datetime import timedelta, datetime
from modules.physEngine.projectiles.projectiles_core import pjtl_Basic, pjtl_Constructed, ProjectileListController
from modules.physEngine.core import CalculationUtilites
from modules.physEngine.basic_objects import lBody, CalculationUtilites, staticBody, dynamicBody
from modules.utils import ConfigLoader
import numpy as np
from modules.physEngine.basic_objects import lBody, CalculationUtilites, staticBody
from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
from modules.physEngine.triggers.collector import TriggerQueue
from modules.physEngine.world_constants import WorldPhysConstants
import random
#==SPACE==#

class Mine_type1(staticBody, dynamicBody):
        def __init__(self, x, y):
                staticBody.__init__(self)
                dynamicBody.__init__(self, x, y, "mine_type1_"+str(id(self)))
                self.set_marker_type("projectile")
                self.manual_init()
                self.master_id = "master_of_game"
                self.ship_detection_radius = ConfigLoader().get("mines.mine_type1_detection_radius",float)
                self.explosion_radius = ConfigLoader().get("mines.mine_type1_explosion_radius",float)
                self.boosters = False
                ProjectileListController().add(self.master_id, self.mark_id)
#==SPACE==#

#==SPACE==#

        def do_cache(self):
                super().do_cache()
                ProjectileListController().remove(self.master_id, self.mark_id)
#==SPACE==#

        def do_uncache(self):
                super().do_uncache()
                ProjectileListController().add(self.master_id, self.mark_id)
#==SPACE==#

#==SPACE==#

        def __del__(self):
                ProjectileListController().remove(self.master_id, self.mark_id)
#==SPACE==#

#==SPACE==#

        def update_position(self):
                super().update_position()
                if not self.boosters:
                        potential_targets = [a for a in EntityIDGroupsController().get("radar_detectable")]
                        potential_targets = self.get_entities_ids_from_list_in_range(potential_targets, self.ship_detection_radius, False)
                        if potential_targets:
                                self.detonate(True)
#==SPACE==#

        def get_description(self, requester_id = None):
                result = super().get_description(requester_id)
                result["master_id"] = self.master_id
                result['detection_radius'] = self.ship_detection_radius
                result["vel"] = self.get_velocity_np_static().tolist()
                return result
#==SPACE==#

#==SPACE==#
            
        def put_description(self, descr, forced=False):
                super().put_description(descr, forced)
#==SPACE==#

        def detonate(self, activated = False):
                activation_radius = self.explosion_radius
                if not activated:
                        activation_radius = max(0.1,self.explosion_radius/4)
                TriggerQueue().add("explosion", self.mark_id, {"danger_radius":activation_radius, "position": self.get_position_np(), "master_id": self.master_id})
                self.status = "destroyed"
                self.self_destruct()
#==SPACE==#

        def self_destruct(self):
                TriggerQueue().add("selfdestruct", self.mark_id, {})
                self.status = "destroyed"
                ProjectileListController().remove(self.master_id, self.mark_id)
#==SPACE==#

#==SPACE==#

        def takes_damage(self, damage_value, damage_type = "explosion", damage_source = None):
                print(self.__class__.__name__, damage_type)
                match damage_type:
                        case "explosion":
                                self.detonate()
                        case "emp":
                                self.self_destruct()
                        case 'collision':
                                self.self_destruct()
#==SPACE==#

#==SPACE==#

#==SPACE==#

class Mine_type2(Mine_type1):
        def __init__(self, x, y):
                super().__init__(x,y)
                self.ship_detection_radius = ConfigLoader().get("mines.mine_type2_detection_radius",float)
                self.explosion_radius = ConfigLoader().get("mines.mine_type2_explosion_radius",float)
                self.detonation_radius = ConfigLoader().get("mines.mine_type2_detonation_radius",float)
                self.status = "launched"
                self.target_id = None
                self.ttl = ConfigLoader().get("mines.mine_type2_ttl",float)*WorldPhysConstants().get_ticks_per_second()
                self.buster_acceleration = ConfigLoader().get("projectile_builder.buster_acceleration", float)*2
                self.boosters = True
#==SPACE==#

        def update_position(self):
                if self.status != "locked":
                        super().update_position()
                        potential_targets = [a for a in EntityIDGroupsController().get("radar_detectable")]
                        potential_targets = self.get_entities_ids_from_list_in_range(potential_targets, self.ship_detection_radius)
                        if potential_targets:
                                self.status = "locked"
                                self.activation_timestamp = WorldPhysConstants().current_frame()
                                self.target_id = random.choice(potential_targets)
#==SPACE==#

                elif self.status == "locked":
                        if WorldPhysConstants().current_frame() - self.activation_timestamp > self.ttl:
                                self.detonate(activated=True)
                        target_pos = self.lBodies[self.target_id].get_position_np()
                        vector = target_pos-self.get_position_np()
                        acceleration = self.get_acceleration_gravity(self.positions[1])+CalculationUtilites.get_projections(self.buster_acceleration, vector)
                        self.velocities[2]=self.velocities[1]+WorldPhysConstants().get_timestep()*acceleration
                        self.update_predictions()
#==SPACE==#

                        reachable_bodies = self.get_entities_ids_list_in_range(self.lBodies.bodies, self.detonation_radius, False)
                        if reachable_bodies:
                                self.detonate(activated = True)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#
            

###===###.\back01\modules\physEngine\projectiles\projectiles_core.py
from modules.physEngine.basic_objects import predictableBody
from modules.physEngine.active_objects import destructableObject
from modules.physEngine.core import CalculationUtilites
import numpy as np
from modules.physEngine.triggers.collector import TriggerQueue
from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
from modules.physEngine.world_constants import WorldPhysConstants
import random
from modules.utils import ConfigLoader
from modules.physEngine.solar_flare.solar_flar_defendzone import SolarFlareDefendZone
#==SPACE==#

class ProjectileListController:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(ProjectileListController, cls).__new__(cls)
            cls._instance.projectile_ids = {}
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get(self, req_master_id, belongs_to_me = False):
        result = []
        for master_id in self.projectile_ids:
            if master_id != req_master_id:
                result = result+self.projectile_ids[master_id]
        return result
#==SPACE==#

    def add(self, master_id, mark_id):
        if master_id not in self.projectile_ids:
            self.projectile_ids[master_id] = []
#==SPACE==#

        if mark_id not in self.projectile_ids[master_id]:
            self.projectile_ids[master_id].append(mark_id)
#==SPACE==#

    def remove(self, master_id, mark_id):
        if master_id in self.projectile_ids:
            if mark_id in self.projectile_ids[master_id]:
                self.projectile_ids[master_id].remove(mark_id)
#==SPACE==#

    def clear(self):
        self.projectile_ids = []
#==SPACE==#

#==SPACE==#

class pjtl_Basic(predictableBody):#,destructableObject):
    def __init__(self, master_id):
        predictableBody.__init__(self, 9999999,999999)
        #destructableObject.__init__(self, self.mark_id)
        self.master_id = master_id
        self.set_marker_type("projectile")
        self.positions[1] = np.array([9999999,999999])
        self.status = "launched"
        if self.master_id in self.lBodies.bodies:
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.status = "loaded"
        self.predictor_depth = 5
        self.explosion_radius = 0
        self.velocity_penalty = 1
        self.template = {}
        self.set_predictor_state(True)
        self.pjtl_name = self.__class__.__name__
        self.damage_zone_radius = self.explosion_radius
        self.is_decoy = False
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        #self.delete_self_from_dwell()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_aim(self, vel_angle, vel_scalar):
        vel = self.get_vel_from_angular(vel_angle, vel_scalar)*self.velocity_penalty
        self.launch_vector = vel
        self.set_actual_vel()
        self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

    def get_vel_from_angular(self, angle, speed):
        vector = np.array([1,0])
        vector = CalculationUtilites.rotate_vector(vector, angle)
        vel = CalculationUtilites.get_projections(speed, vector)
        return vel
#==SPACE==#

    def set_params(self, params):
        pass
#==SPACE==#

    def get_params_template(self):
        return self.template
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_description(self, requester_id = None):
        result = super().get_description(requester_id)
        result["master_id"] = self.master_id
        result['explosion_radius'] = self.damage_zone_radius
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def set_actual_vel(self):
            vel = self.launch_vector+self.lBodies.bodies[self.master_id].get_velocity_np()
            self.velocities[2] = vel
            self.velocities[1] = vel
            self.velocities[0] = vel
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
    def launch(self):
        self.launch_timestamp = WorldPhysConstants().current_frame()
        self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
        self.positions[2] = self.lBodies.bodies[self.master_id].get_position_np()
        self.status = "launched"
        ProjectileListController().add(self.master_id, self.mark_id)
#==SPACE==#

    def takes_damage(self, damage_value, damage_type = "explosion", damage_source = None):
        print(self.__class__.__name__, damage_type)
        match damage_type:
            case "explosion":
                self.detonate()
            case "emp":
                self.self_destruct()
            case 'collision':
                self.self_destruct()
            case 'radiation':
                self.detonate()
#==SPACE==#

    def detonate(self):
        TriggerQueue().add("detonate", self.mark_id, {"danger_radius":self.explosion_radius})
        self.set_predictor_state(False)
        self.status = "destroyed"
        SolarFlareDefendZone().remove(self.mark_id)
#==SPACE==#

    def self_destruct(self):
        super().self_destruct()
        ProjectileListController().remove(self.master_id, self.mark_id)
        SolarFlareDefendZone().remove(self.mark_id)
#==SPACE==#

from math import sqrt, pow
#==SPACE==#

class pjtl_Constructed(pjtl_Basic):
    def __init__(self, master_id, pjtl_name, pjtl_description, dumb = False):
        self.template = {}
        if not dumb: pjtl_Basic.__init__(self, master_id)
        self.parse_pjtl_description(pjtl_description)
        self.pjtl_name = pjtl_name
        self.target_id = None
        self.type = pjtl_name
        self.radar_levels = [
            (0.5, "activity"),
            (0.75, "active_ship"),
        ]
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        #if not dumb: SolarFlareDefendZone().add(self.mark_id)
#==SPACE==#

    def set_params(self, params):
        if 'activation_delay' in params:
            activation_delay = float(params["activation_delay"])
            self.predictor_depth = (float(activation_delay)+float(self.ttl_delay))*(self.thrusters+1)
            self.activation_delay = WorldPhysConstants().get_ticks_in_seconds(activation_delay)
            self.upload_state_to_predictor()
#==SPACE==#

    def get_description(self, requester_id = None):
        result = super().get_description(requester_id)
        if self.detection_radius:
            result["detection_radius"] = self.detection_radius
        if self.detonation_radius:
            result["detonation_radius"] = self.detonation_radius
#==SPACE==#

        return result
#==SPACE==#

    def parse_pjtl_description(self, pjtl_description):
#==SPACE==#

        time_step = ConfigLoader().get("projectile_builder.time_step", float)
        radius_step= ConfigLoader().get("projectile_builder.radius_step", float)
        exp_radius_step = ConfigLoader().get("projectile_builder.exp_radius_step", float)
#==SPACE==#

        self.thrusters = pjtl_description["thruster"]
#==SPACE==#

        prediction_depth = 0
        activation_delay = pjtl_description["timer"]*time_step
        self.max_activation_delay = 0
        if activation_delay:
            self.template["activation_delay"] = [0, activation_delay, 1, activation_delay]
            self.max_activation_delay = activation_delay
#==SPACE==#

            prediction_depth = prediction_depth+activation_delay
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        self.activation_delay = WorldPhysConstants().get_ticks_in_seconds(self.max_activation_delay)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

        ttl = pjtl_description["inhibitor"]*time_step
        self.ttl_delay = 0
        if ttl:
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
            self.ttl_delay = ttl
            prediction_depth = prediction_depth+ttl
        self.ttl = WorldPhysConstants().get_ticks_in_seconds(seconds=self.ttl_delay)
#==SPACE==#

        self.predictor_depth = float(prediction_depth)*(self.thrusters+1)
        #self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

        self.explosion_radius = round(pow(pjtl_description["explosive"],0.3)*exp_radius_step)
        self.explosive_damage = self.explosion_radius*ConfigLoader().get("damage.explosion_damage_per_sec", float)*ConfigLoader().get("damage.explosive_duration", float)
        self.emp_radius = round(pow(pjtl_description["emp"],0.3)*exp_radius_step)
        self.damage_zone_radius = max(self.explosion_radius, self.emp_radius)
        self.thrusters = pjtl_description["thruster"]
        self.ship_detection_radius = pjtl_description["entities_detection"]*radius_step
        self.projectiles_detection_radius = pjtl_description["projectiles_detection"]*radius_step
        self.detection_radius = max(self.ship_detection_radius, self.projectiles_detection_radius)
#==SPACE==#

        self.busters = pjtl_description["buster"]
        self.buster_acceleration = ConfigLoader().get("projectile_builder.buster_acceleration", float)*self.busters
#==SPACE==#

        self.detonation_radius = pjtl_description["detonator"]*radius_step
        self.is_decoy = False
        if pjtl_description["decoy"]:
            self.is_decoy = True
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.details_count = sum(pjtl_description.values())
        self.velocity_penalty = self.get_vel_penalty(pjtl_description)
#==SPACE==#

    def get_vel_penalty(self,pjtl_description):
        sum_vel_penalty = ConfigLoader().get("projectile_builder_velpenalty.detail_penalty", float)*self.details_count
        thrusters_penalty = ConfigLoader().get("projectile_builder_velpenalty.thrusters", float)*self.thrusters
        busters_penalty = ConfigLoader().get("projectile_builder_velpenalty.busters", float)*self.busters
        sensors_count = pjtl_description["entities_detection"]+pjtl_description["projectiles_detection"]+pjtl_description["detonator"]
        sensors_penalty = ConfigLoader().get("projectile_builder_velpenalty.sensors", float)*sensors_count
        explosives_penalty = ConfigLoader().get("projectile_builder_velpenalty.explosives", float)*pjtl_description["explosive"]
        sum_vel_penalty = sum_vel_penalty+thrusters_penalty+busters_penalty+sensors_penalty+explosives_penalty
        return round(max(0,1-sum_vel_penalty),2)
#==SPACE==#

    def get_stats(self):
        return{
            "activation_time": self.max_activation_delay,
            "ttl_time": self.ttl_delay,
            "explosion_radius/damage": f"{self.explosion_radius}/{self.explosive_damage}",
            "emp_radius": self.emp_radius,
            "speed_up": self.thrusters+1,
            "ship_detection_radius": self.ship_detection_radius,
            "projectiles_detection_radius": self.projectiles_detection_radius,
            "details": self.details_count,
            "velocity_penalty": self.velocity_penalty,
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            #self.hbody_idx = self.lBodies.bodies[self.master_id].hbody_idx
            self.set_current_dwell(self.lBodies.bodies[self.master_id].last_hbody_idx)
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            if WorldPhysConstants().current_frame() - self.launch_timestamp > self.activation_delay:
                self.status = "activated"
                if self.is_decoy:
                    EntityIDGroupsController().add(self.mark_id, ["radar_detectable"])
                self.activation_timestamp = WorldPhysConstants().current_frame()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
            self.update_predictions()
            for i in range(self.thrusters):
                self.update_predictions()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "activated":
            if WorldPhysConstants().current_frame() - self.activation_timestamp > self.ttl:
                self.detonate(activated=True)
#==SPACE==#

            if self.ship_detection_radius:
                potential_targets = [a for a in EntityIDGroupsController().get("radar_detectable")]
                if self.master_id in potential_targets:
                    potential_targets.remove(self.master_id)
                potential_targets = self.get_entities_ids_from_list_in_range(potential_targets, self.ship_detection_radius, False)
                if potential_targets:
                    if self.busters:
                        self.status = "locked"
                        self.target_id = random.choice(potential_targets)
                    else:
                        self.detonate(activated=True)
#==SPACE==#

            if self.projectiles_detection_radius:
                potential_targets = ProjectileListController().get(self.master_id)
                potential_targets = self.get_entities_ids_from_list_in_range(potential_targets, self.projectiles_detection_radius, False)
                if potential_targets:
                    if self.busters:
                        self.status = "locked"
                        self.target_id = random.choice(potential_targets)
                        self.velocities[2] = self.velocities[2]*self.thrusters
                        self.velocities[1] = self.velocities[1]*self.thrusters
                    else:
                        self.detonate(activated=True)
#==SPACE==#

            self.update_predictions()
            for i in range(self.thrusters):
                self.update_predictions()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        elif self.status == "locked":
            if WorldPhysConstants().current_frame() - self.activation_timestamp > self.ttl:
                self.detonate(activated=True)
#==SPACE==#

#==SPACE==#

            acceleration = np.array([0,0])
            if self.target_id in self.lBodies.bodies:
                target_pos = self.lBodies[self.target_id].get_position_np()
                vector = target_pos-self.get_position_np()
                acceleration = self.get_acceleration_gravity(self.positions[1])+CalculationUtilites.get_projections(self.buster_acceleration, vector)
            self.velocities[2]=self.velocities[1]+WorldPhysConstants().get_timestep()*acceleration
            self.update_predictions()
#==SPACE==#

            reachable_bodies = [a for a in self.get_entities_ids_list_in_range(self.lBodies.bodies, self.detonation_radius, False)]
            if self.master_id in reachable_bodies:
                reachable_bodies.remove(self.master_id)
            if reachable_bodies:
                self.detonate(activated = True)
#==SPACE==#

#==SPACE==#

    def detonate(self, activated = False):
        if activated:
            if self.explosion_radius:
                TriggerQueue().add("explosion", self.mark_id, {"danger_radius":self.explosion_radius,
                                                                "position": self.get_position_np(),
                                                                "master_id": self.master_id})
            if self.emp_radius:
                TriggerQueue().add("emp_explosion",self.mark_id, {"danger_radius":self.emp_radius,
                                                                    "position": self.get_position_np(),
                                                                    "master_id": self.master_id})
        else:
            TriggerQueue().add("explosion", self.mark_id, {"danger_radius":max(0.1,self.explosion_radius/4), "position": self.get_position_np(), "master_id": self.master_id})
        self.set_predictor_state(False)
        self.self_destruct()
        if self.is_decoy:
            EntityIDGroupsController().remove(self.mark_id)
        self.status = "destroyed"
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            

###===###.\back01\modules\physEngine\projectiles\projectile_selector.py
from modules.physEngine.projectiles.explosives import pjtl_TimedExplosive, pjtl_TriggerExplosive, pjtl_TimedTorpedo, pjtl_HomingLRMissile
from modules.physEngine.projectiles.mine import pjtl_Mine
from modules.physEngine.projectiles.support import pjtl_TimedEMP
from modules.physEngine.projectiles.drones import io_Drone
#==SPACE==#

#==SPACE==#

class ProjectileSelector:
    def get_projectiles_list():
        return ["pjtl_TimedExplosive", "pjtl_TriggerExplosive", "pjtl_Mine", "pjtl_TimedEMP", "io_Drone", "pjtl_TimedTorpedo", "pjtl_HomingLRMissile"]
#==SPACE==#

    def get_projectile_by_classname(classname, master_id):
        match classname:
            case "pjtl_TimedExplosive": return pjtl_TimedExplosive(master_id)
            case "pjtl_TriggerExplosive": return pjtl_TriggerExplosive(master_id)
            case "pjtl_Mine": return pjtl_Mine(master_id)
            case "pjtl_TimedEMP": return pjtl_TimedEMP(master_id)
            case "io_Drone": return io_Drone(master_id)
            case 'pjtl_TimedTorpedo': return pjtl_TimedTorpedo(master_id)
            case "pjtl_HomingLRMissile": return pjtl_HomingLRMissile(master_id)
        return None

###===###.\back01\modules\physEngine\projectiles\support.py
from datetime import timedelta, datetime
import numpy as np
from modules.physEngine.projectiles.projectiles_core import pjtl_Basic
from modules.physEngine.core import CalculationUtilites
from modules.physEngine.triggers.collector import TriggerQueue
from modules.utils import ConfigLoader
#==SPACE==#

#not implemented
#вырубает четыре пункта электричества на вражеском корабле на 5 секунд
class pjtl_TimedEMP(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.predictor_depth = 5
        self.ttl = timedelta(seconds=self.predictor_depth)
        self.launch_timestamp = 5
        self.explosion_radius = ConfigLoader().get("projectile_params.pjtl_timedemp_exprad", float)
#==SPACE==#

    def set_params(self, params):
        if 'detonation_time' in params:
            self.predictor_depth = float(params["detonation_time"])
            self.ttl = timedelta(seconds=self.predictor_depth)
            self.upload_state_to_predictor()
#==SPACE==#

    def get_params_template(self):
        return {
            'detonation_time':[0,10,1,5]
        }
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
            if (datetime.now() - self.launch_timestamp)>self.ttl:
                self.detonate()
#==SPACE==#

    def takes_damage(self, damage_value, damage_type = "explosion", damage_source = None):
        self.self_destruct()
#==SPACE==#

#==SPACE==#

    def detonate(self):
        TriggerQueue().add("emp_detonate",self.mark_id, {"danger_radius":self.explosion_radius})
        self.set_predictor_state(False)
        self.status = "destroyed"
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#not implemented
#пока находишься внутри, видимость - 0.25%
class pjtl_TimedStealthCloak(pjtl_Basic):
    def __init__(self, master_id):
        super().__init__(master_id)
        self.predictor_depth = 5
        self.ttl = timedelta(seconds=self.predictor_depth)
        self.launch_timestamp = 5
        self.explosion_radius = 50
#==SPACE==#

    def set_params(self, params):
        if 'detonation_time' in params:
            self.predictor_depth = float(params["detonation_time"])
            self.ttl = timedelta(seconds=self.predictor_depth)
            self.upload_state_to_predictor()
#==SPACE==#

    def get_params_template(self):
        return {
            'detonation_time':[0,10,1,5]
        }
#==SPACE==#

    def update_position(self):
        if self.status=="loaded":
            self.positions[1] = self.lBodies.bodies[self.master_id].get_position_np()
            self.set_actual_vel()
            self.upload_state_to_predictor()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        elif self.status == "launched":
            self.update_predictions()
            if (datetime.now() - self.launch_timestamp)>self.ttl:
                self.detonate()

###===###.\back01\modules\physEngine\quests\quest_controller.py
#==SPACE==#

import json
from modules.utils import Command
class QuestPointsController:
#==SPACE==#

    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(QuestPointsController, cls).__new__(cls)
            cls._instance.quest_points = {}
            quest_points_desr = json.load(open("quest_points/quest_points.json"))
            for quest_point_name in quest_points_desr:
                cls._instance.quest_points[quest_point_name] = QuestPointTrigger(quest_points_desr[quest_point_name])
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

        return cls._instance
    def __init__(self) -> None:
        pass
#==SPACE==#

    def load_triggers(self):
        pass
#==SPACE==#

    def check_trigger(self, trigger):
        for qp_name in self.quest_points:
            result = self.quest_points[qp_name].check(trigger)
            if result:
                self.quest_points[qp_name].set_state(result)
                break
#==SPACE==#

    def get_quest_point_state(self, qp_name):
        return self.quest_points[qp_name].completed
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def toogle_quest_point_state(self, qp_name):
        self.quest_points[qp_name].completed = not self.quest_points[qp_name].completed
#==SPACE==#

    def get_state(self):
        result = {}
        for qp_name in self.quest_points:
            result[qp_name] = self.quest_points[qp_name].completed
        return result
#==SPACE==#

    def proceed_command(self, command:Command):
        action = command.get_action()
        params = command.get_params()
        match action:
            case "toogle_qp_state":
                self.toogle_quest_point_state(params["qp_name"])
    def save(self):
        pass
#==SPACE==#

class QuestPointTrigger:
    def __init__(self, quest_points_descr):
        self.initiator = quest_points_descr["initiator"]
        self.event_type = quest_points_descr["type"]
        self.event_params = quest_points_descr["params"]
        self.depends_on = None
        if "depends_on" in quest_points_descr:
            self.depends_on = quest_points_descr["depends_on"]
        self.completed = False
        pass
#==SPACE==#

    def set_state(self, value:bool):
        self.completed = value
#==SPACE==#

    def check(self, trigger):
        if self.depends_on:
            if not QuestPointsController().get_quest_point_state(self.depends_on):
                return False
        if self.completed: return False
        if self.event_type != trigger["type"]:
            return False
#==SPACE==#

        match self.event_type:
            case "interact":
                if self.initiator == trigger["initiator"]:
                    if self.event_params["target"] == trigger["params"]["target"]:
                        return True
            case 'damage2target':
                if self.initiator == trigger["params"]["master_id"]:
                    if self.event_params["damage_type"] == trigger["params"]["damage_type"]:
                        if self.event_params["target"] == trigger["params"]["target"]:
                            return True
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        return False

###===###.\back01\modules\physEngine\solar_flare\solar_flar_activator.py
from modules.physEngine.solar_flare.solar_flar_defendzone import SolarFlareDefendZone
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.triggers.collector import TriggerQueue
from modules.physEngine.world_constants import WorldPhysConstants
from modules.utils import Command, ConfigLoader
#==SPACE==#

class SolarFlareActivator:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(SolarFlareActivator, cls).__new__(cls)
            cls._instance.lBodies = lBodyPool_Singleton()
            cls._instance.active = False
            damage_per_sec = ConfigLoader().get("damage.solarflare_damage_per_sec", float)
            cls._instance.damage_per_tick = WorldPhysConstants().get_onetick_step(damage_per_sec,1)
            cls._instance.ticks_per_sec = WorldPhysConstants().get_ticks_in_seconds(1)
            cls._instance.activity_period_ticks = ConfigLoader().get("solar_flares.activity_period_sec", float)*cls._instance.ticks_per_sec*60
            cls._instance.sleep_period_ticks = ConfigLoader().get("solar_flares.sleep_period_sec", float)*cls._instance.ticks_per_sec*60
            cls._instance.current_tick = 0
            cls._instance.timer_active = False
        return cls._instance
#==SPACE==#

    def add(self, mark_id):
        pass
#==SPACE==#

    def set_state(self, state):
        self.timer_active = False
        self.current_tick = 0
        self.active = state
#==SPACE==#

#==SPACE==#

    def get_status(self):
        return {
            "state":self.active,
            "timer_state":self.timer_active,
            "time2nextphase": self.get_time2nextphase(),
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_time2nextphase(self):
        return round((self.get_current_timer()-self.current_tick)/self.ticks_per_sec,0)
#==SPACE==#

    def set_timer(self, state):
        self.timer_active = state
#==SPACE==#

    def set_timer_value(self, value):
        new_value = float(value)*self.ticks_per_sec
        self.current_tick = 0
        if self.active:
            self.activity_period_ticks = new_value
            return
        self.sleep_period_ticks = new_value
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def get_current_timer(self):
        if self.active: return self.activity_period_ticks
        else: return self.sleep_period_ticks
#==SPACE==#

    def proceed_command(self, command:Command):
        action = command.get_action()
        params = command.get_params()
        match action:
            case "set_solar_flare":
                self.set_state(params["state"])
            case "set_timer_state":
                self.set_timer(params["state"])
            case "set_timer_value":
                self.set_timer_value(params["value"]
#==SPACE==#

#==SPACE==#

#==SPACE==#
                                    
                )
    def timer_step(self):
        if self.timer_active:
            self.current_tick = self.current_tick+1
            if self.current_tick >= self.get_current_timer():
                self.active = not self.active
                self.current_tick = 0
#==SPACE==#

    def step(self):
        self.timer_step()
        if self.active:
            defended = SolarFlareDefendZone().get_defended()
            for body_id in self.lBodies.bodies:
                if body_id not in defended:
                    TriggerQueue().add("damage2target", "SolarFlare",{'target':body_id,
                                "damage_value":self.damage_per_tick,
                                "damage_type":"radiation"})
#==SPACE==#


###===###.\back01\modules\physEngine\solar_flare\solar_flar_defendzone.py
class SolarFlareDefendZone:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(SolarFlareDefendZone, cls).__new__(cls)
            cls._instance.entities = []
            cls._instance.__current = 0
        return cls._instance
#==SPACE==#

    def add(self, mark_id):
        if mark_id not in self.entities:
            self.entities.append(mark_id)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def remove(self, mark_id):
        if mark_id in self.entities:
            self.entities.remove(mark_id)
#==SPACE==#

    def get_defended(self):
        return self.entities
#==SPACE==#

    def clear(self):
        self.entities = []

###===###.\back01\modules\physEngine\triggers\collector.py
from queue import Queue
#==SPACE==#

class TriggerQueue():
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(TriggerQueue, cls).__new__(cls)
            cls._instance.queue = Queue()
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def add(self, trigger_type, initiator, params):
        self.queue.put({
                "type":trigger_type,
                "initiator":initiator,
                "params":params
        })
#==SPACE==#

    def get(self):
        return self.queue.get()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def empty(self):
        return self.queue.empty()

###===###.\back01\modules\physEngine\triggers\handler.py
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.zones.damage_zone import ae_ExplosionZone, ae_EMPZone
from modules.physEngine.event_system import GlobalEventSystem
from modules.physEngine.interactable_objects.container import ShipDebris, SpaceStationDebris
from modules.physEngine.triggers.collector import TriggerQueue
from modules.ship.shipPool import ShipPool_Singleton
from modules.physEngine.quests.quest_controller import QuestPointsController
from modules.ship.ship import NPC_Ship
from modules.ship.shipPool import ShipPool_Singleton
#==SPACE==#

#==SPACE==#

def get_entity_from_Pools(mark_id, pool_list):
    for pool in pool_list:
        entity = pool.get(mark_id)
        if entity: return entity
    return None
#==SPACE==#

class TriggerHandler:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(TriggerHandler, cls).__new__(cls)
            cls._instance.bodies_to_delete = []
            cls._instance.triggers_list = []
            cls._instance.lBodies = lBodyPool_Singleton()
            cls._instance.cShips = ShipPool_Singleton()
            cls._instance.EventSystem = GlobalEventSystem()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def proceed_triggerSelfDestruct(self, initiator, params):
        self.lBodies.delete(initiator)
#==SPACE==#

    def proceed_triggerSelfExplode(self, initiator, params):
        pos = self.lBodies[initiator].get_position()
        #self.lBodies.delete(initiator)
        expZone = ae_ExplosionZone(pos[0],pos[1], params['danger_radius'])
        self.lBodies.add(expZone)
#==SPACE==#

    def proceed_triggerSelfEmpExplode(self, initiator, params):
        pos = self.lBodies[initiator].get_position()
        #self.lBodies.delete(initiator)
        expZone = ae_EMPZone(pos[0],pos[1], params['danger_radius'])
        self.lBodies.add(expZone)
#==SPACE==#

    def proceed_triggerDamage2Target(self, initiator, params):
        mark_id = params['target']
        damage_value = params["damage_value"]
        damage_type = params["damage_type"]
        target = get_entity_from_Pools(mark_id, [self.cShips, self.lBodies])
        if not target: return
        if hasattr(target, "takes_damage"):
            target.takes_damage(damage_value, damage_type, initiator)
#==SPACE==#

    def proceed_triggerAddResource(self, initiator, params):
        self.EventSystem.add_resource(params['target'],params["resource_name"], params["resource_amount"])
#==SPACE==#

    def hBodyCollision(self, initiator, params):
        self.EventSystem.hBodyCollision(params['target'])
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def proceed_triggerExplosion(self, initiator, params):
        pos = params["position"]
        danger_radius = params['danger_radius']
        expZone = ae_ExplosionZone(pos[0],pos[1], danger_radius, params["master_id"])
        self.lBodies.add(expZone)
#==SPACE==#

    def proceed_triggerEmpExplosion(self, initiator, params):
        pos = params["position"]
        danger_radius = params['danger_radius']
        expZone = ae_EMPZone(pos[0],pos[1], danger_radius,params["master_id"])
        self.lBodies.add(expZone)
#==SPACE==#

    def ShipDefeat(self, initiator, params):
        position = self.lBodies[initiator].get_position_np()
        velocity = self.lBodies[initiator].velocities[1]
#==SPACE==#

        ShipPool_Singleton().delete(initiator)
        debris =ShipDebris(position[0], position[1], initiator+"[debris]")
        debris.set_position_and_velocity(position, velocity)
        self.lBodies.add(debris)
#==SPACE==#

    def StationDefeat(self, initiator, params):
        position = self.lBodies[initiator].get_position_np()
        clockwise = self.lBodies[initiator].clockwise
        self.lBodies.delete(initiator)
        debris = SpaceStationDebris(position[0], position[1], initiator+"[debris]")
        debris.set_position_np_manual(position, clockwise)
        self.lBodies.add(debris)
#==SPACE==#

#==SPACE==#

    def StationDefence(self, initiator, params):
        position = self.lBodies[initiator].get_position_np()
        velocity = self.lBodies[initiator].get_velocity_np()
        defender = params["defender"]
        defender_level = params["defender_level"]
        npc_defender = NPC_Ship(position[0], position[1], defender)
        ShipPool_Singleton().spawn(npc_defender)
        self.lBodies[npc_defender.mark_id].set_position_and_velocity_init(position, velocity)
        self.lBodies[npc_defender.mark_id].stabilize_orbit()
        self.cShips.ships[npc_defender.mark_id].set_level(defender_level)
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def proceed_interaction(self ,initiator, params):
        pass
#==SPACE==#

    def proceed_triggers_list(self):
        while not TriggerQueue().empty():
            trigger = TriggerQueue().get()
            trigger_type = trigger["type"]
            match trigger_type:
                case "selfdestruct":
                    self.proceed_triggerSelfDestruct(trigger["initiator"], trigger["params"])
#==SPACE==#

                case "explosion":
                    self.proceed_triggerExplosion(trigger["initiator"], trigger["params"])
#==SPACE==#

                case 'emp_explosion':
                    self.proceed_triggerEmpExplosion(trigger["initiator"], trigger["params"])
#==SPACE==#

                case "damage2target":
                    self.proceed_triggerDamage2Target(trigger["initiator"], trigger["params"])
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
                case 'addresource':
                    self.proceed_triggerAddResource(trigger["initiator"], trigger["params"])
#==SPACE==#

                case 'hBodyCollision':
                    self.hBodyCollision(trigger["initiator"], trigger["params"])
#==SPACE==#

                case 'ship_defeat':
                    self.ShipDefeat(trigger["initiator"], trigger["params"])
#==SPACE==#

                case 'station_defeat':
                    self.StationDefeat(trigger["initiator"], trigger["params"])
#==SPACE==#

#==SPACE==#

                case 'activate_station_defence':
                    self.StationDefence(trigger["initiator"], trigger["params"])
#==SPACE==#

                case 'interact':
                    self.proceed_interaction(trigger["initiator"], trigger["params"])
            QuestPointsController().check_trigger(trigger)
#==SPACE==#

        self.triggers_list = []
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#


###===###.\back01\modules\physEngine\zones\damage_zone.py
from datetime import datetime, timedelta
from modules.physEngine.active_objects import destructableObject
from modules.physEngine.basic_objects import lBody
from modules.physEngine.world_constants import WorldPhysConstants
from modules.utils import ConfigLoader
from modules.physEngine.triggers.collector import TriggerQueue
#==SPACE==#

class ae_BasicZone(lBody,destructableObject):
    def __init__(self, x, y):
        lBody.__init__(self, x, y)
        destructableObject.__init__(self, self.mark_id)
        self.marker_type = "ae_BasicZone"
        self.blast_type = self.__class__.__name__
        self.is_detectable = False
#==SPACE==#

    def get_description(self, requester_id = None):
        result = super().get_description(requester_id)
        result["type"] = "ae_BasicZone"
        result["danger_radius"] = self.danger_radius
        result["blast_type"] = self.blast_type
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
import time
#==SPACE==#

#==SPACE==#

#==SPACE==#

class ae_ExplosionZone(ae_BasicZone):
    def __init__(self, x, y, danger_radius, master_id):
        super().__init__(x, y)
        self.danger_radius = danger_radius
        self.master_id = master_id
        duration = ConfigLoader().get("damage.explosive_duration", float)
        self.ttl = WorldPhysConstants().get_ticks_in_seconds(duration) #timedelta(seconds=duration)
        self.launch_timestamp = WorldPhysConstants().current_frame() #time.perf_counter()# datetime.now()
        damage_per_second = ConfigLoader().get("damage.explosion_damage_per_sec", float)*danger_radius
#==SPACE==#

        self.damage_per_step = WorldPhysConstants().get_onetick_step(damage_per_second*duration,duration)
#==SPACE==#

#==SPACE==#

    def update_position(self):
        reachable_bodies = self.get_entities_ids_list_in_range(self.lBodies.bodies, self.danger_radius, False)
        for body_id in reachable_bodies:
            distance = self.get_distance2entity(body_id)
            damage2target = self.damage_per_step*(1-distance/self.danger_radius)
            TriggerQueue().add("damage2target", self.mark_id,{'target':body_id,
                                                                "master_id": self.master_id,
                                "damage_value":damage2target,
                                "damage_type":"explosion"})
        time_now = WorldPhysConstants().current_frame()#time.perf_counter()
        time_delta = time_now - self.launch_timestamp
        if time_delta>self.ttl:
            self.self_destruct()
#==SPACE==#

#==SPACE==#

class ae_EMPZone(ae_BasicZone):
    def __init__(self, x, y, danger_radius, master_id):
        super().__init__(x, y)
        self.master_id = master_id
        self.danger_radius = danger_radius
        self.ttl = timedelta(seconds=2)
        self.launch_timestamp = datetime.now()
#==SPACE==#

#==SPACE==#

    def update_position(self):
        reachable_bodies = self.get_entities_ids_list_in_range(self.lBodies.bodies, self.danger_radius, False)
        for body_id in reachable_bodies:
            TriggerQueue().add("damage2target", self.mark_id,{'target':body_id, "master_id": self.master_id,
                                "damage_value":4/60,
                                "damage_type":"emp"})
#==SPACE==#

        if (datetime.now() - self.launch_timestamp)>self.ttl:
            self.self_destruct()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#


###===###.\back01\modules\physEngine\zones\meteors_zone.py
from modules.physEngine.basic_objects import lBody, CalculationUtilites, staticBody
from modules.physEngine.entity_id_groups_controller import EntityIDGroupsController
from modules.physEngine.triggers.collector import TriggerQueue
from modules.utils import ConfigLoader
from modules.physEngine.world_constants import WorldPhysConstants
import numpy as np
#==SPACE==#

#==SPACE==#

#==SPACE==#

class MeteorsCloud(staticBody, lBody):
    def __init__(self, x,y, mark_id = None):
        staticBody.__init__(self)
        self.manual_init()
        lBody.__init__(self, x,y, mark_id)
        self.danger_radius = 40
        self.marker_type = self.__class__.__name__
        damage_per_sec = ConfigLoader().get("damage.meteors_coud_damage_per_sec",float)
        self.damage_per_tick = WorldPhysConstants().get_onetick_step(damage_per_sec,1)
        self.stabilize_orbit()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_description(self, requester_id=None):
        result = super().get_description(requester_id)
        result["danger_radius"] = self.danger_radius
        result["vel"] = self.get_velocity_np_static().tolist()
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def put_description(self, descr, foced):
        self.danger_radius = descr["danger_radius"]
        self.set_velocity(np.array(descr["vel"]))
#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def update_position(self):
        super().update_position()
#==SPACE==#

        reachable_bodies = self.get_entities_ids_from_list_in_range(EntityIDGroupsController().get("is_ships"), self.danger_radius, False)
        for body_id in reachable_bodies:
            TriggerQueue().add("damage2target", self.mark_id,{'target':body_id,
                                "damage_value":self.damage_per_tick,
                                "damage_type":"radiation"})

###===###.\back01\modules\ship\projectile_blueprints.py
from modules.physEngine.projectiles.projectiles_core import pjtl_Constructed
from modules.utils import ConfigLoader
#==SPACE==#

#==SPACE==#

class ProjectileConstructorController:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(ProjectileConstructorController, cls).__new__(cls)
            cls._instance.blueprints = {}
            cls._instance.prices = {}
#==SPACE==#

        return cls._instance
#==SPACE==#

    def get_basic_blueprints(self):
        return {
            "basic":{
                    "timer":1,
                    "inhibitor":1,
                    "thruster":0,
                    "explosive":1,
                    "emp":0,
                    "entities_detection":0,
                    "projectiles_detection":0,
                    "buster": 0,
                    "detonator":0,
                    "decoy":0
            },
            "torpedo":{
                    "timer":0,
                    "inhibitor":1,
                    "thruster":2,
                    "explosive":3,
                    "emp":0,
                    "entities_detection":0,
                    "projectiles_detection":0,
                    "buster": 0,
                    "detonator":0,
                    "decoy":0
            },
            "interceptor":{
                    "timer":0,
                    "inhibitor":1,
                    "thruster":1,
                    "explosive":0,
                    "emp":2,
                    "entities_detection":0,
                    "projectiles_detection":5,
                    "buster": 1,
                    "detonator":2,
                    "decoy":0
            },
            "interceptor_back":{
                    "timer":0,
                    "inhibitor":1,
                    "thruster":0,
                    "explosive":0,
                    "emp":2,
                    "entities_detection":0,
                    "projectiles_detection":5,
                    "buster": 1,
                    "detonator":2,
                    "decoy":0
            },
            "torpeda_mk2":{
                    "timer":3,
                    "inhibitor":0,
                    "thruster":2,
                    "explosive":3,
                    "emp":0,
                    "entities_detection":0,
                    "projectiles_detection":0,
                    "buster": 0,
                    "detonator":0,
                    "decoy":0
            },
            "basic_mk2":{
                    "timer":2,
                    "inhibitor":0,
                    "thruster":1,
                    "explosive":2,
                    "emp":0,
                    "entities_detection":0,
                    "projectiles_detection":0,
                    "buster": 0,
                    "detonator":0,
                    "decoy":0
            },
        }
#==SPACE==#

    def initiate_ship_blueprints(self, ship_mark_id):
        basic_bps = self.get_basic_blueprints()
        self.blueprints[ship_mark_id] = basic_bps
        self.prices[ship_mark_id] = {}
        for bp_name in basic_bps:
            self.prices[ship_mark_id][bp_name] = self.get_blueprint_cost(basic_bps[bp_name])
#==SPACE==#

#==SPACE==#

    def append_blueprint(self, ship_mark_id, name, pjtl_description):
        self.blueprints[ship_mark_id][name] = pjtl_description
        self.prices[ship_mark_id][name] = self.get_blueprint_cost(pjtl_description)
#==SPACE==#

    def get_blueprint(self, ship_mark_id, name):
        a = self.blueprints[ship_mark_id][name]
        return a
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_cost(self, ship_mark_id, name):
        a = self.prices[ship_mark_id][name]
        return a
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_volume(self, ship_mark_id, name):
        pjtl = pjtl_Constructed(None, None, self.blueprints[ship_mark_id][name], dumb = True)
        stats = pjtl.get_stats()
        return stats["details"]
#==SPACE==#

#==SPACE==#

    def get_blueprints_list(self, ship_mark_id):
        return(list(self.blueprints[ship_mark_id].keys()))
#==SPACE==#

    def get_blueprint_cost(self, pjtl_description):
        sum = 0
        for comp_name in pjtl_description:
            sum = sum+ConfigLoader().get(f"projectile_builder_cost.{comp_name}", float)*pjtl_description[comp_name]
        return sum
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_production_time(self, pjtl_description):
        return 10
#==SPACE==#

    def get_stats(self, pjtl_description):
        pjtl = pjtl_Constructed(None, None, pjtl_description, dumb=True)
        stats = pjtl.get_stats()
        stats["cost"] = self.get_blueprint_cost(pjtl_description)
        stats["production_time"] = 5 #stats["details"]*ConfigLoader().get(f"projectile_builder_cost.one_detail_time_production", float)
        return stats
#==SPACE==#
    
#==SPACE==#

    def get_description(self, mark_id):
        return {
            "blueprints":self.blueprints[mark_id]
        }
#==SPACE==#
    
    def put_description(self, mark_id, descr):
        self.blueprints[mark_id] = descr["blueprints"]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\modules\ship\ship.py
#==SPACE==#

from modules.ship.shipPool import ShipPool_Singleton
from modules.physEngine.core import lBodyPool_Singleton
from modules.utils import Command, CommandQueue, ConfigLoader,get_dt_ms, PerformanceCollector
from modules.ship.systems.sm_core import BasicShipSystem
from modules.ship.systems.sm_core import GlobalShipSystemController
from modules.ship.systems.sm_launcher import LauncherSystem
from modules.ship.systems.sm_engine import EngineSystem, NPC_Kraken_EngineSystem
from modules.ship.systems.sm_energy import EnergySystem
from modules.ship.systems.sm_radar import RadarSystem
from modules.ship.systems.sm_resources import ResourcesSystem
from modules.ship.systems.sm_damage import DamageSystem, CrewSystem,NPC_DamageSystem
from modules.ship.systems.sm_RnD import ResearchAndDevSystem
from modules.ship.systems.sm_interact import InteractionSystem
from modules.ship.systems.sm_medicine import MedicineSystem
from datetime import datetime
#==SPACE==#

#==SPACE==#

class CapMarksController:
    def __init__(self):
        self.marks = {}
        self.selected_char = None
        for a in ["A", "B", "C", "D", "E"]:
            self.marks[a] ={
                                "position":[0,0],
                                "active":False,
                                "selected": False
                            }
    def proceed_command(self, cmd: Command):
        action = cmd.get_action()
        params = cmd.get_params()
        match action:
            case "make_point":
                if self.selected_char not in self.marks: return
                self.marks[self.selected_char] = {
                    "position":params["position"],
                    "active":True
                }
                self.selected_char = None
            case "deactivate_point":
                if params["char"] not in self.marks: return
                self.marks[params["char"]]["active"] = False
#==SPACE==#

            case "select_point":
                if params["char"] not in self.marks: return
                for a in self.marks:
                    self.marks[a]["selected"] = False
                self.selected_char = params["char"]
                self.marks[self.selected_char]["selected"] = True
#==SPACE==#

    def get_marks(self):
        return self.marks
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
class Ship:
    def __init__(self, pos_x, pos_y, mark_id = None):
        self.mark_id = mark_id if mark_id else str(id(self))
#==SPACE==#

        GlobalShipSystemController().add(self.mark_id, "engine_sm", EngineSystem(pos_x, pos_y, mark_id))
        GlobalShipSystemController().add(self.mark_id, "launcher_sm", LauncherSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "resources_sm", ResourcesSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "crew_sm", CrewSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "damage_sm", DamageSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "interact_sm", InteractionSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "radar_sm", RadarSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "energy_sm", EnergySystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "RnD_sm", ResearchAndDevSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "med_sm", MedicineSystem(mark_id))
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.systems_state = GlobalShipSystemController().get_status(self.mark_id)
        self.get_system("RnD_sm").upgrade_to_config_state()
        self.get_system("launcher_sm").update_available_projectile()
        self.get_system("energy_sm").set_max_power()
        self.get_system("radar_sm").update_scanrange()
        self.cap_marks = CapMarksController()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def get_system(self, system_name):
        return GlobalShipSystemController().get(self.mark_id, system_name)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_viewfield(self):
        data = {}
        data["state_data"] = self.systems_state
        data["observer_id"] = self.mark_id
        data["nav_data"] = self.get_system("radar_sm").get_nav_data()
        data["cap_marks"] = self.cap_marks.get_marks()
        return data
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_short_description(self):
        data = {
            "hp":self.get_system("damage_sm").get_short_description(),
            "RnD":self.get_system("RnD_sm").get_short_description(),
            "pos": self.get_system("engine_sm").get_position(),
        }
        return data
#==SPACE==#

    def gain_resource(self, resource_name,resource_amount):
        self.get_system("resources_sm").add_resource(resource_name,resource_amount)
#==SPACE==#

    def proceed_command(self, command:Command):
        if command.contains_level("cap_marks"):
            self.cap_marks.proceed_command(command)
            return
        res = GlobalShipSystemController().proceed_command(self.mark_id, command)
        if not res:
            self.proceed_related_command(command)
#==SPACE==#

    def proceed_related_command(self,command:Command):
        action = command.get_action()
        prams = command.get_params()
        match action:
            case "destroy": self.destroy()
#==SPACE==#

    def get_state(self):
        pass
#==SPACE==#

    def delete(self):
        self.get_system("launcher_sm").unload()
        GlobalShipSystemController().delete(self.mark_id)
#==SPACE==#

    def set_level(self, ship_level):
        self.get_system("RnD_sm").set_ship_level(ship_level)
#==SPACE==#

#==SPACE==#

    def takes_damage(self, damage_value, damage_type, damage_source = None):
        self.get_system("damage_sm").takes_damage(damage_value, damage_type, damage_source)
#==SPACE==#

    def next_step(self):
        tmp_t1 = datetime.now()
        GlobalShipSystemController().next_step(self.mark_id)
        tmp_t2= datetime.now()
        self.systems_state = GlobalShipSystemController().get_status(self.mark_id)
        tmp_t3 = datetime.now()
        PerformanceCollector().add("Ship.iter_loop.next_step", get_dt_ms(tmp_t1, tmp_t2))
        PerformanceCollector().add("Ship.iter_loop.get_status", get_dt_ms(tmp_t2, tmp_t3))
#==SPACE==#

    def get_description(self):
        result = {"mark_id":self.mark_id, "type": self.__class__.__name__, "systems":{}}
        system_list = GlobalShipSystemController().get_systems_list(self.mark_id)
        for system_name in system_list:
            result["systems"][system_name] = self.get_system(system_name).get_description()
        return result
#==SPACE==#

    def put_description(self, descr, forced=False):
        system_list = GlobalShipSystemController().get_systems_list(self.mark_id)
        for system_name in system_list:
            try:
                self.get_system(system_name).put_description(descr["systems"][system_name])
            except Exception as e:
                print(f"ship[{self.mark_id}].put_description", e)
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

class NPC_Ship(Ship):
    def __init__(self, pos_x, pos_y, mark_id = None):
        self.mark_id = mark_id if mark_id else str(id(self))
        GlobalShipSystemController().add(self.mark_id, "engine_sm", EngineSystem(pos_x, pos_y, mark_id, ship_subtype = "NPC_Ship"))
        GlobalShipSystemController().add(self.mark_id, "launcher_sm", LauncherSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "resources_sm", ResourcesSystem(mark_id, True))
        GlobalShipSystemController().add(self.mark_id, "damage_sm", NPC_DamageSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "radar_sm", RadarSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "energy_sm", EnergySystem(mark_id, NPC = True))
        GlobalShipSystemController().add(self.mark_id, "RnD_sm", ResearchAndDevSystem(mark_id, True))
        self.systems_state = GlobalShipSystemController().get_status(self.mark_id)
        self.get_system("launcher_sm").update_available_projectile()
        self.get_system("radar_sm").update_scanrange()
        self.get_system("RnD_sm").upgrade_to_config_state()
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def get_viewfield(self):
        data = {}
        data["state_data"] = self.systems_state
        data["observer_id"] = self.mark_id
        data["nav_data"] = self.get_system("radar_sm").get_nav_data()
        return data
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

class NPC_Kraken(Ship):
    def __init__(self, pos_x, pos_y, mark_id = None):
        self.mark_id = mark_id if mark_id else str(id(self))
        GlobalShipSystemController().add(self.mark_id, "engine_sm", NPC_Kraken_EngineSystem(pos_x, pos_y, mark_id, ship_subtype = "Kraken"))
        GlobalShipSystemController().add(self.mark_id, "damage_sm", NPC_DamageSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "radar_sm", RadarSystem(mark_id))
        GlobalShipSystemController().add(self.mark_id, "energy_sm", EnergySystem(mark_id, NPC = True))
        GlobalShipSystemController().add(self.mark_id, "RnD_sm", ResearchAndDevSystem(mark_id))
        self.systems_state = GlobalShipSystemController().get_status(self.mark_id)
        self.get_system("radar_sm").update_scanrange()
        #self.get_system("RnD_sm").upgrade_to_config_state()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def get_viewfield(self):
        data = {}
        data["state_data"] = self.systems_state
        data["observer_id"] = self.mark_id
        data["nav_data"] = self.get_system("radar_sm").get_nav_data()
        return data
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    

###===###.\back01\modules\ship\shipPool.py
from modules.physEngine.core import lBodyPool_Singleton
from modules.utils import Command, CommandQueue, ConfigLoader
from modules.ship.systems.sm_core import BasicShipSystem
#==SPACE==#

class ShipPool_Singleton:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(ShipPool_Singleton, cls).__new__(cls)
            cls._instance.ships = {}
            cls._instance.__current = 0
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get(self,mark_id):
        if mark_id in self.ships:
            return self.ships[mark_id]
        return None
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def __getitem__(self, key):
        return self.ships[key]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def __next__(self):
        return self.ships.__next__()
#==SPACE==#

    def spawn(self, ShipEntity):
        self.ships[ShipEntity.mark_id] = ShipEntity
#==SPACE==#

    def proceed_command(self, command:Command):
        try:
            target_id = command.get_target_id("ship")
            if target_id in self.ships:
                self.ships[target_id].proceed_command(command)
        except Exception as e:
            print(repr(e))
#==SPACE==#

    def next_step(self):
        cmd_queue = CommandQueue()
        while not cmd_queue.is_empty():
            self.proceed_command(cmd_queue.get_next())
        for target_id in self.ships:
            self.ships[target_id].next_step()
#==SPACE==#

    def clear(self):
        ship_list = list(self.ships.keys())
        for k in ship_list:
            self.delete(k)
#==SPACE==#

    def delete(self, mark_id):
        if mark_id in self.ships:
            self.ships[mark_id].delete()
            self.ships.pop(mark_id)
#==SPACE==#

#==SPACE==#

    def get_ships_description(self):
        result = {}
        for shipname in self.ships:
            result[shipname] = self.ships[shipname].get_description()
        return result

###===###.\back01\modules\ship\systems\sm_core.py
from modules.utils import Command, CommandQueue, PerformanceCollector, get_dt_ms
from datetime import datetime
#==SPACE==#

#==SPACE==#

class GlobalShipSystemController:
    _instance = None # Приватное поле для хранения единственного экземпляра
#==SPACE==#

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(GlobalShipSystemController, cls).__new__(cls)
            cls._instance.systems = {}
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        return cls._instance
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def add(self, mark_id, system_name, system_class_obj):
        if mark_id not in self.systems:
            self.systems[mark_id] = {}
        self.systems[mark_id][system_name] = system_class_obj
#==SPACE==#

    def get(self, mark_id, system_name):
        try:
            return self.systems[mark_id][system_name]
        except Exception as e:
            return None
#==SPACE==#
        
    def get_systems_list(self, mark_id):
        result  = [sm_name for sm_name in self.systems[mark_id]]
        return result
#==SPACE==#

    def next_step(self, mark_id):
        for sm_name in self.systems[mark_id]:
            tmp_t1 = datetime.now()
            self.systems[mark_id][sm_name].next_step()
            tmp_t2 = datetime.now()
            PerformanceCollector().add(f"Ship.system.{sm_name}", get_dt_ms(tmp_t1, tmp_t2))
#==SPACE==#

    def get_status(self, mark_id):
        res = {}
        for sm_name in self.systems[mark_id]:
            tmp_t1 = datetime.now()
            res[sm_name] = self.systems[mark_id][sm_name].get_status()
            tmp_t2 = datetime.now()
            PerformanceCollector().add(f"Ship.status.{sm_name}", get_dt_ms(tmp_t1, tmp_t2))
        return res
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def delete(self, mark_id):
        for sm_name in self.systems[mark_id]:
            self.systems[mark_id][sm_name].delete()
        del self.systems[mark_id]
#==SPACE==#

    def proceed_command(self, mark_id, command:Command):
        for sm_name in self.systems[mark_id]:
            if command.contains_level(sm_name):
                self.systems[mark_id][sm_name].proceed_command(command)
                return True
        return False
#==SPACE==#

class BasicShipSystem:
    def __init__(self, master_id, sm_name):
        self.sm_name = sm_name
        self.mark_id = master_id
        self.status = "OK"
        self.power = 0.25
        self.upgrade_level = 1
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def get_system(self, system_name):
        return GlobalShipSystemController().get(self.mark_id, system_name)
#==SPACE==#

#==SPACE==#
    
    def get_description(self):
        result = {
            "sm_name":self.sm_name,
            "mark_id":self.mark_id,
            "power":self.power,
            "upgrade_level": self.upgrade_level
        }
        return result
#==SPACE==#

    def put_description(self, descr):
        self.power = descr["power"]
        self.set_level(descr["upgrade_level"])
#==SPACE==#

#==SPACE==#
        
    def set_level(self, value):
        func = self.upgrade
        if value<self.upgrade_level:
            func = self.downgrade
#==SPACE==#

        for i in range(abs(value-self.upgrade_level)):
            func()
#==SPACE==#

#==SPACE==#
            
    def get_status(self):
        return {
            "mark_id":self.mark_id,
            "status":self.status,
#==SPACE==#

            #float - percentage of optimum
            #"power": self.power,
#==SPACE==#

            #integer
            "upgrade_level": self.upgrade_level
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def send_command(self, level, command, params):
        cmd_content = {
            "level":"ship."+level,
            "target_id":self.mark_id,
            "action":command,
            "params":params
        }
        cmd_obj = Command(cmd_content)
        CommandQueue().add_command(cmd_obj)
#==SPACE==#

#==SPACE==#

    def proceed_command(self, cmd:Command):
        action = cmd.get_action()
        match action:
            case "upgrade": self.upgrade()
            case "downgrade": self.downgrade()
            case "set_power":
                self.power = cmd.get_params()["power"]
#==SPACE==#

    def set_power(self, value):
        self.power = value
        if self.power>1:
            self.get_system("damage_sm").inform_system_overload(self.sm_name,self.power-1)
        else:
            self.get_system("damage_sm").inform_system_normalload(self.sm_name)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def actualize(self):
        pass
#==SPACE==#

    def upgrade(self):
        self.upgrade_level = self.upgrade_level+1
        self.actualize()
#==SPACE==#

    def downgrade(self):
        self.upgrade_level = max(self.upgrade_level-1,0)
        self.actualize()
#==SPACE==#

    def next_step(self):
        pass
#==SPACE==#

    def delete(self):
        pass

###===###.\back01\modules\ship\systems\sm_damage.py
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.world_constants import WorldPhysConstants
from modules.physEngine.projectiles.projectile_selector import ProjectileSelector
from modules.utils import Command
#==SPACE==#

from modules.ship.systems.sm_core import BasicShipSystem, GlobalShipSystemController
#==SPACE==#

from modules.ship.shipPool import ShipPool_Singleton
from modules.utils import Command
from modules.utils import Command, CommandQueue, ConfigLoader
from modules.physEngine.triggers.collector import TriggerQueue
#==SPACE==#

#==SPACE==#

import random
import math
#==SPACE==#

class RepairTeam:
    def __init__(self, mark_id, name):
        self.mark_id = mark_id
        self.name = name
        self.state = "idle"
#==SPACE==#

        #экипаж в комане
        self._crew = 10
        self.crew_out = self.crew
        self.max_crew = 10
#==SPACE==#

        #количество материалов. Хватает на одну полную починку.
        self.loadout = 100
        self.max_loadout = 100
#==SPACE==#

        self.repair_step = WorldPhysConstants().get_onetick_step(100,60)
        self.recovery_step = WorldPhysConstants().get_onetick_step(100,60)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

        self._resources_sm = None
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

        #1 юнит экипажа стоит где-то 50 единиц металла
        self.damage_penalty = 1/50
#==SPACE==#

    @property
    def resources_sm(self):
        if not self._resources_sm:
            self.resources_sm = GlobalShipSystemController().get(self.mark_id, "resources_sm")
        return self._resources_sm
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    @resources_sm.setter
    def resources_sm(self, value):
        self._resources_sm = value
#==SPACE==#

    @property
    def crew(self):
        return self._crew
#==SPACE==#

    @crew.setter
    def crew(self, value):
        self._crew = value
        self.crew_out = math.ceil(self._crew)
#==SPACE==#

    def get_state(self):
        return {
            "name":self.name,
            "crew":self.crew_out,
            "loadout":self.loadout/self.max_loadout,
            "state":self.state
        }
#==SPACE==#

    def set_state(self, state):
        self.state = state
#==SPACE==#

    def get_repair_step(self):
        if self.loadout==0: return 0
        repair_step = (self.crew/self.max_crew)*self.repair_step
        self.loadout = max(self.loadout-self.repair_step, 0)
        return repair_step
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def next_step(self):
        if self.state=="idle":
            if self.loadout<self.max_loadout:
                success = self.resources_sm.spend_resource("metal",self.recovery_step)
                if success:
                    self.loadout = min(self.max_loadout, self.loadout+self.recovery_step)
#==SPACE==#

    def add_crew_to_team(self):
        if self.crew<self.max_crew:
            self.crew= self.crew+1
            return True
        return False
#==SPACE==#

    def remove_crew_from_team(self):
        if self.crew>0:
            self.crew = self.crew-1
            return True
        return False
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def takes_damage(self, damage):
        self.crew = max(0,self.crew-damage*self.damage_penalty)
#==SPACE==#

#==SPACE==#

    def get_description(self):
        return {
            "name":self.name,
            "crew":self._crew,
            "loadout":self.loadout,
            "state":self.state
        }
#==SPACE==#

    def put_description(self, descr):
        self.name = descr["name"]
        self._crew = descr["crew"]
        self.loadout = descr["loadout"]
        self.state = descr["state"]
#==SPACE==#
        
#==SPACE==#

from modules.ship.systems.sm_medicine import MedicineSystem
#==SPACE==#

#==SPACE==#

class CrewSystem(BasicShipSystem):
    def __init__(self, mark_id):
        super().__init__(mark_id, "crew_sm")
        self.free_crew = 0
        self.total_crew = 0
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.teams = {}
        for name in ['smith', 'johnson', 'wake', 'sharp']:
            self.teams[name] = RepairTeam(self.mark_id, name)
            self.total_crew = self.total_crew+10
#==SPACE==#

        self.system_names = ["engine_sm", "launcher_sm", "energy_sm", "radar_sm", "resources_sm"]
        self.system_status = {}
        for sm_name in self.system_names:
            self.system_status[sm_name] = None
#==SPACE==#

        self.crew_acceleration = ConfigLoader().get("sm_crew.crew_acceleration", float)
#==SPACE==#

        self._med_sm:MedicineSystem = None
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    @property
    def med_sm(self):
        if not self._med_sm:
            self._med_sm = GlobalShipSystemController().get(self.mark_id, "med_sm")
        return self._med_sm
#==SPACE==#

#==SPACE==#

    def get_description(self):
        result = super().get_description()
        result["free_crew"] = self.free_crew
        result["total_crew"] = self.total_crew
        result["system_status"] = self.system_status
        result["teams"] = {
            team_name:self.teams[team_name].get_description() for team_name in self.teams
        }
        return result
#==SPACE==#
    
    def put_description(self, descr):
        super().put_description(descr)
        self.free_crew = descr["free_crew"]
        self.total_crew = descr["total_crew"]
        self.system_status = descr["system_status"]
        for team_name in descr["teams"]:
            team_descr = descr["teams"][team_name]
            self.teams[team_name].put_description(team_descr)
#==SPACE==#

    @med_sm.setter
    def med_sm(self, value):
        self._med_sm = value
#==SPACE==#

    def get_status(self):
        result = super().get_status()
        teams = {}
        for rteam_name, rteam_obj in self.teams.items():
            teams[rteam_name] = rteam_obj.get_state()
        result["teams"] = teams
        result["systems"] = self.system_status
        result["total_crew"] = self.total_crew
        result["free_crew"] = self.free_crew
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def next_step(self):
        super().next_step()
        for team_name in self.teams:
            self.teams[team_name].next_step()
        #ship defeat
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def proceed_command(self, cmd: Command):
        action = cmd.get_action()
        match action:
            case "add_crew_to_team":
                self.add_crew_to_team(cmd.get_params()["team_name"])
#==SPACE==#

            case "remove_crew_from_team":
                self.remove_crew_from_team(cmd.get_params()["team_name"])
#==SPACE==#

            case "assign_team":
                params = cmd.get_params()
                self.assign_team(params["team_name"], params["sm_name"])
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_density(self):
        pass
#==SPACE==#

    def takes_damage2system(self, sm_name, damage):
        assigned_team = self.system_status[sm_name]
        if assigned_team:
            self.teams[assigned_team].takes_damage(damage)
        new_total_crew = math.ceil(self.get_total_crew_number())
        diff = self.total_crew-new_total_crew
        if diff>0:
            self.med_sm.add_unit_to_hospital(diff)
            self.total_crew = new_total_crew
#==SPACE==#

    def get_total_crew_number(self):
        return sum([a[1].crew_out for a in self.teams.items()])
#==SPACE==#

    def assign_team(self, team_name, sm_name):
        assigned_team = self.system_status[sm_name]
        if assigned_team:
                self.teams[assigned_team].set_state("idle")
                self.system_status[sm_name] = None
#==SPACE==#

        if team_name:
            current_state = self.teams[team_name].state
            if current_state!="idle":
                self.system_status[current_state] = None
            self.teams[team_name].set_state(sm_name)
            self.system_status[sm_name] = team_name
#==SPACE==#

    def get_crew_acceleration_in_system(self, sm_name):
        team_name = self.system_status[sm_name]
        if team_name:
            return self.crew_acceleration*self.teams[team_name].crew_out/self.teams[team_name].max_crew
        return 0
#==SPACE==#

    def add_crew_to_team(self, team_name):
        if self.free_crew>0:
            result = self.teams[team_name].add_crew_to_team()
            if result:self.free_crew=self.free_crew-1
#==SPACE==#

    def add_unit_to_crew(self, value):
        self.total_crew = self.total_crew+value
        self.free_crew = self.free_crew + value
#==SPACE==#

    def remove_crew_from_team(self, team_name):
        result = self.teams[team_name].remove_crew_from_team()
        if result:self.free_crew=self.free_crew+1
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def get_repair_step(self, sm_name):
        if not self.system_status[sm_name]: return 0
        repair_hp = self.teams[self.system_status[sm_name]].get_repair_step()
        return repair_hp
#==SPACE==#

#==SPACE==#

#==SPACE==#

class DamageSystem(BasicShipSystem):
    def __init__(self, mark_id):
        super().__init__(mark_id, "damage_sm")
        #basic
        self.systems_hp = {}
        self.hp_level_step = 100
        self.system_names = ["engine_sm", "launcher_sm", "energy_sm", "radar_sm", "resources_sm"]
        for sm_name in self.system_names:
            self.systems_hp[sm_name] = {
                'current_hp':self.hp_level_step,
                "max_hp":self.hp_level_step,
            }
#==SPACE==#

        #energy overload
        energyoverlock_damage_per_sec = ConfigLoader().get("damage.energyoverlock_damage_per_sec", float)
        self.energyoverlock_damage_per_tick = WorldPhysConstants().get_onetick_step(energyoverlock_damage_per_sec,1)
        self.overloaded = {}
#==SPACE==#

#==SPACE==#

        #taking damage marker
        self.is_taking_damage = False
        self.taking_damage_showoff_time = WorldPhysConstants().get_ticks_in_seconds(1)
        self.last_taking_damage_timestamp = WorldPhysConstants().current_frame()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

        #crew link
        self._crew_sm = None
#==SPACE==#

        #TODO delete later
        self.tmp_damage_log = {}
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    @property
    def crew_sm(self):
        if not self._crew_sm:
            self.crew_sm = GlobalShipSystemController().get(self.mark_id, "crew_sm")
        return self._crew_sm
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    @crew_sm.setter
    def crew_sm(self, value):
        self._crew_sm = value
#==SPACE==#

#==SPACE==#

    def inform_system_upgrade(self, system_name):
        self.systems_hp[system_name]["current_hp"] = 5
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def get_description(self):
        result = super().get_description()
        result["systems_hp"] = self.systems_hp
        result["crew"] = self.crew_sm.get_description()
        return result
#==SPACE==#
    
    def put_description(self, descr):
        super().put_description(descr)
        self.systems_hp = descr["systems_hp"]
        self.crew_sm.put_description(descr["crew"])
#==SPACE==#
        
#==SPACE==#

    def inform_system_overload(self, system_name, power_overcome):
        self.overloaded[system_name] = power_overcome
#==SPACE==#

    def inform_system_normalload(self, system_name):
        if system_name in self.overloaded:
            del self.overloaded[system_name]
#==SPACE==#

    def next_step(self):
        super().next_step()
        #energy overload
        for system_name in self.overloaded:
            damage = self.energyoverlock_damage_per_tick*self.overloaded[system_name]
            self.cause_damage2system(system_name, damage)
#==SPACE==#

        #taking damage marker
        self.is_taking_damage = (WorldPhysConstants().current_frame()-self.last_taking_damage_timestamp)<self.taking_damage_showoff_time
#==SPACE==#

        #repair by crew
        self.repair_step()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def repair_step(self):
        for sm_name in self.systems_hp:
            if self.systems_hp[sm_name]["current_hp"]<self.systems_hp[sm_name]["max_hp"]:
                repair_hp = self.crew_sm.get_repair_step(sm_name)
                if repair_hp:
                    self.systems_hp[sm_name]["current_hp"] = min(self.systems_hp[sm_name]["max_hp"],self.systems_hp[sm_name]["current_hp"]+repair_hp)
#==SPACE==#

#==SPACE==#

    def can_be_upgraded(self, system_name):
        return (self.systems_hp[system_name]["current_hp"]/self.systems_hp[system_name]["max_hp"])>0.9
#==SPACE==#

    def cause_damage2system(self, system_name, damage):
        if system_name not in self.systems_hp: return
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.systems_hp[system_name]['current_hp'] = self.systems_hp[system_name]['current_hp']-damage
#==SPACE==#

#==SPACE==#

        if self.systems_hp[system_name]['current_hp']<=0:
                self.systems_hp[system_name]['current_hp'] = 0
#==SPACE==#

                if self.get_system("RnD_sm").get_upgrade_level(system_name)>0:
                    self.get_system("RnD_sm").downgrade_system(system_name)
                    self.systems_hp[system_name]['current_hp']=self.systems_hp[system_name]['max_hp']
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def get_status(self):
        status = super().get_status()
        status["systems_hp"] = self.systems_hp
        status["is_taking_damage"] = self.is_taking_damage
        return status
#==SPACE==#

#==SPACE==#

    def get_short_description(self):
        return "100/100"
#==SPACE==#

#==SPACE==#
        
    def proceed_command(self, command:Command):
        super().proceed_command(command)
        match command.get_action():
            case "takes_damage":
                self.takes_damage(command.get_params()["damage_value"], command.get_params()["damage_type"])
            case 'repair_system_admin':
                system_name = command.get_params()["system_name"]
                self.systems_hp[system_name]['current_hp'] = self.systems_hp[system_name]['max_hp']
#==SPACE==#

    def takes_damage(self, damage_value, damage_type = 'explosion', damage_source = None):
        self.last_taking_damage_timestamp = WorldPhysConstants().current_frame()
#==SPACE==#

        targeted_system_name = "energy_sm"
        if damage_source:
            targeted_system_idx = abs(hash(damage_source))%5
            targeted_system_name = self.system_names[targeted_system_idx]
        else:
            targeted_system_name = random.choice(self.system_names)
#==SPACE==#

        #temprary for balance calculation
        if damage_source not in self.tmp_damage_log:
            self.tmp_damage_log[damage_source]=0
#==SPACE==#

        #TODO delete later
        self.tmp_damage_log[damage_source] = self.tmp_damage_log[damage_source]+damage_value
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        match damage_type:
            case "explosion":
                #system_name = random.choice(list(self.systems_hp.keys()))
                self.cause_damage2system(targeted_system_name,damage_value)
                self.crew_sm.takes_damage2system(targeted_system_name, damage_value)
            case "emp":
                self.get_system("energy_sm").takes_emp_damage(damage_value, ConfigLoader().get("damage.emp_duration", float))
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
            case 'collision':
                system_name = random.choice(list(self.systems_hp.keys()))
                modulo = damage_value%1
                for i in range(int(damage_value)):
                    self.cause_damage2system(system_name,1)
                self.cause_damage2system(system_name,modulo)
                self.crew_sm.takes_damage2system(system_name, damage_value)
#==SPACE==#

            case "radiation":
                system_name = random.choice(list(self.systems_hp.keys()))
                self.cause_damage2system(system_name,damage_value)
                #self.crew_sm.takes_damage2system(system_name, damage_value)
#==SPACE==#

class NPC_DamageSystem(BasicShipSystem):
#==SPACE==#

    def __init__(self, mark_id):
        super().__init__(mark_id, "damage_sm")
        self.total_max_hp = 150
        self.hp_state = {
            "total_hp":{
                'current_hp':self.total_max_hp,
                "max_hp":self.total_max_hp,
            }
        }
                #taking damage marker
        self.is_taking_damage = False
        self.taking_damage_showoff_time = WorldPhysConstants().get_ticks_in_seconds(1)
        self.last_taking_damage_timestamp = WorldPhysConstants().current_frame()
#==SPACE==#

        self.hp_list = [100, 125, 150, 200]
#==SPACE==#

    def next_step(self):
        super().next_step()
        #energy overload
#==SPACE==#

#==SPACE==#

        #taking damage marker
        self.is_taking_damage = (WorldPhysConstants().current_frame()-self.last_taking_damage_timestamp)<self.taking_damage_showoff_time
#==SPACE==#

    def set_hp(self, value):
        self.hp_state = {
            "total_hp":{
                'current_hp':value,
                "max_hp":value,
            }
        }
#==SPACE==#

    def upgrade(self):
        super().upgrade()
        self.set_hp(self.hp_list[self.upgrade_level])
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def downgrade(self):
        super().downgrade()
        self.set_hp(self.hp_list[self.upgrade_level])
#==SPACE==#

    def inform_system_overload(self, system_name, power_overcome):
        pass
#==SPACE==#

    def inform_system_normalload(self, system_name):
        pass
#==SPACE==#

#==SPACE==#

    def get_short_description(self):
        max_hp = round(self.hp_state["total_hp"]["max_hp"],2)
        curr_hp = self.hp_state["total_hp"]["current_hp"]
        return f"{curr_hp}/{max_hp}"
#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

    def get_status(self):
        status = super().get_status()
        status["systems_hp"] = self.hp_state
        status["is_taking_damage"] = self.is_taking_damage
        return status
#==SPACE==#

    def proceed_command(self, command:Command):
        super().proceed_command(command)
        params = command.get_params()
        match command.get_action():
            case "takes_damage":
                self.takes_damage(command.get_params()["damage_value"], command.get_params()["damage_type"])
#==SPACE==#

            case 'set_NPC_hp':
                self.hp_state["total_hp"]["current_hp"] = params["value"]
                self.hp_state["total_hp"]["max_hp"] = params["value"]
#==SPACE==#

#==SPACE==#

    def takes_damage(self, damage_value, damage_type = 'explosion', damage_source = None):
        self.last_taking_damage_timestamp = WorldPhysConstants().current_frame()
        match damage_type:
            case "explosion":
                self.hp_state["total_hp"]["current_hp"] = self.hp_state["total_hp"]["current_hp"]-damage_value
            case "emp":
                self.get_system("energy_sm").takes_emp_damage(damage_value, ConfigLoader().get("damage.emp_duration", float))
            case 'collision':
                self.hp_state["total_hp"]["current_hp"] = self.hp_state["total_hp"]["current_hp"]-damage_value
            case "radiation":
                self.hp_state["total_hp"]["current_hp"] = self.hp_state["total_hp"]["current_hp"]-damage_value
#==SPACE==#

        if self.hp_state["total_hp"]["current_hp"]<=0:
            TriggerQueue().add("ship_defeat", self.mark_id, {})

###===###.\back01\modules\ship\systems\sm_energy.py
from modules.ship.systems.sm_core import BasicShipSystem
from modules.utils import Command
from datetime import datetime, timedelta
#==SPACE==#

class EnergySystem(BasicShipSystem):
    def __init__(self, mark_id, NPC = False):
        super().__init__(mark_id, "energy_sm")
        self.max_power_supply = 4
        self.systems_energy = {
            "engine_sm": 1,
            "launcher_sm": 1,
            "radar_sm": 1,
        }
        if not NPC:
                self.systems_energy["resources_sm"] = 1
        self.energy_level_upgrade = 3
        self.energy_limit = self.get_energy_limit()
        self.debuffs = []
#==SPACE==#

    def get_energy_limit(self):
        return 1+self.upgrade_level*self.energy_level_upgrade
#==SPACE==#

    def get_energy_usage(self):
        return sum(self.systems_energy.values())
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_energy_free(self):
        return self.energy_limit - self.get_energy_usage()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def set_max_power(self):
        for system_name in self.systems_energy.keys():
            self.systems_energy[system_name] = 4
            self.get_system(system_name).set_power(1)
        self.get_system("radar_sm").change_energy_magnitude(16)
#==SPACE==#

    def get_status(self):
        status = super().get_status()
        status["systems_energy"] = self.systems_energy
        status["max_power_supply"] = self.max_power_supply
        status["energy_free"] = self.get_energy_free()
        return status
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def shift_energy_level(self, system_name, step):
        result = self.systems_energy[system_name]+step
        if result<0: return
        self.get_system("radar_sm").change_energy_magnitude(step)
        self.systems_energy[system_name] = result
        power_supply = self.systems_energy[system_name]/self.max_power_supply
        self.get_system(system_name).set_power(power_supply)
#==SPACE==#

    def next_step(self):
        debuff_value = 0
        if len(self.debuffs)>0:
            time_now = datetime.now()
            shift_outdated = None
            for i,(emp_damage, exp_ttime) in enumerate(self.debuffs):
                if time_now<exp_ttime:
                    debuff_value = debuff_value+emp_damage
                else:
                    shift_outdated= i
            if shift_outdated: self.debuffs = self.debuffs[shift_outdated+1:]
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        debuff_value = int(debuff_value)
#==SPACE==#

        self.energy_limit = max(0,self.get_energy_limit() - debuff_value)
#==SPACE==#

        energy_shrinkage = self.get_energy_usage()-self.energy_limit
        if (energy_shrinkage>0):
            for i in range(energy_shrinkage):
                idx = i%len(self.systems_energy)
                system_name = list(self.systems_energy.keys())[idx]
                self.shift_energy_level(system_name, -1)
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
    def proceed_command(self, command:Command):
        super().proceed_command(command)
        match command.get_action():
            case 'increase_energy_level':
                if self.get_energy_free()<1: return
                system_name = command.get_params()["system"]
                self.shift_energy_level(system_name,1)
#==SPACE==#

            case 'decrease_energy_level':
                system_name = command.get_params()["system"]
                if self.systems_energy[system_name]<1: return
                self.shift_energy_level(system_name,-1)
#==SPACE==#

            case 'emp_damage':
                damage_value = command.get_params()["damage_value"]
                duration = command.get_params()["duration"]
                self.takes_emp_damage(damage_value,duration)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
#==SPACE==#

#==SPACE==#

    def takes_emp_damage(self, damage_value, duration):
        self.debuffs.append((damage_value, datetime.now()+timedelta(seconds=duration)))
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

    def upgrade(self):
        super().upgrade()
        self.energy_limit = self.upgrade_level*self.energy_level_upgrade
#==SPACE==#

    def downgrade(self):
        super().downgrade()
        self.energy_limit = self.upgrade_level*self.energy_level_upgrade
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        

###===###.\back01\modules\ship\systems\sm_engine.py
#==SPACE==#

from modules.ship.systems.sm_core import BasicShipSystem
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.active_objects import ae_Ship
from modules.physEngine.world_constants import WorldPhysConstants
from modules.utils import Command, ConfigLoader, PerformanceCollector, get_dt_ms
from datetime import datetime
import numpy as np
#==SPACE==#

from modules.ship.systems.sm_damage import CrewSystem
from modules.ship.systems.sm_core import GlobalShipSystemController
#==SPACE==#

class EngineSystem(BasicShipSystem):
    def __init__(self,pos_x, pos_y, mark_id, ship_subtype = "ae_Ship"):
        super().__init__(mark_id, "engine_sm")
        self.mark_id = mark_id
        self.lBodies = lBodyPool_Singleton()
        self.lBodies.add(ae_Ship(pos_x, pos_y, self.mark_id, ship_subtype))
#==SPACE==#

#==SPACE==#

        #мощность двигателя на разном уровне прокачки
        self.thrust_levels = ConfigLoader().get("sm_engine.thrust_levels", list)
#==SPACE==#

        #кривая генерации перегрева
        self.burning_period = ConfigLoader().get("sm_engine.burning_period", float)
        ticks_per_sec = WorldPhysConstants().get_ticks_per_second()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.heatcap_levels = [t*self.burning_period*ticks_per_sec for t in self.thrust_levels]
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.heat_level_limit = self.heatcap_levels[self.upgrade_level]
        self.heat_level = 0
        self.max_thrust = self.thrust_levels[self.upgrade_level]
#==SPACE==#

        time_limit = ConfigLoader().get("sm_engine.cooling_period", float)
        self.cooling_normal_speed = WorldPhysConstants().get_onetick_step(self.heat_level_limit,time_limit)
#==SPACE==#

        rotation360time_levels = ConfigLoader().get("sm_engine.rotation360time_levels", list)
        self.rotation_levels = [360/rot360_time for rot360_time in rotation360time_levels]
#==SPACE==#

        self.reverse_penalty = ConfigLoader().get("sm_engine.reverse_penalty", float)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

        self.acceleration = 0
        self.rotation = 0
        self._crew_sm = None
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    @property
    def crew_sm(self):
        if not self._crew_sm:
            self.crew_sm = GlobalShipSystemController().get(self.mark_id, "crew_sm")
        return self._crew_sm
#==SPACE==#

    def get_position(self):
        result = [0,0]
        try:
            result = self.lBodies[self.mark_id].get_position()
        except Exception: pass
        return result
#==SPACE==#

#==SPACE==#
        
    @crew_sm.setter
    def crew_sm(self, value):
        self._crew_sm = value
#==SPACE==#

#==SPACE==#
    
    def get_description(self):
        result = super().get_description()
        result["lbody"] = self.lBodies[self.mark_id].get_description()
        return result
#==SPACE==#
    
    def put_description(self, descr):
        super().put_description(descr)
        self.lBodies[self.mark_id].put_description(descr["lbody"])
#==SPACE==#

    def get_actual_heat_generated(self):
        actual_thrust = abs(self.acceleration)
        heat_generated = actual_thrust
        return heat_generated
#==SPACE==#

    def next_step(self):
        if self.heat_level>=self.heat_level_limit:
            self.lBodies[self.mark_id].set_acceleration(0)
#==SPACE==#

        heat_generated = self.get_actual_heat_generated()
#==SPACE==#

        if heat_generated==0:
            if self.heat_level <= self.heat_level_limit:
                cooling_speed = self.get_cooling_speed()
                self.heat_level = max(self.heat_level-cooling_speed, 0)
        else:
            self.heat_level = min(self.heat_level_limit,self.heat_level + heat_generated)
#==SPACE==#

#==SPACE==#

    def get_status(self):
        status = super().get_status()
        status['heat_level'] = round((self.heat_level/self.heat_level_limit)*100,2)
        status["velocity"] = round(self.lBodies[self.mark_id].get_abs_velocity(),2)
        status["direction"] = round(self.lBodies[self.mark_id].direction%360,2)
        status["deltaV"] = round(self.burning_period*self.thrust_levels[self.upgrade_level]*(1-self.heat_level/self.heat_level_limit), 2)
#==SPACE==#

#==SPACE==#

        return status
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_cooling_speed(self):
        crew_acc= self.crew_sm.get_crew_acceleration_in_system("engine_sm") if self.crew_sm else 0
        return self.cooling_normal_speed*(1+crew_acc)*self.power
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_actual_thrust(self, thrust_percentage):
        actual_thrust = self.max_thrust*thrust_percentage
        if actual_thrust<0: actual_thrust = actual_thrust*self.reverse_penalty
        return actual_thrust
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def proceed_command(self, command:Command):
        super().proceed_command(command)
        match command.get_action():
            case 'set_prediction_depth':
                self.set_prediction_depth(command.get_params())
            case 'set_acceleration':
                self.set_acceleration(command.get_params())
            case "exhaust_heat":
                pass
#==SPACE==#

#==SPACE==#

    def set_prediction_depth(self, params):
        self.lBodies[self.mark_id].set_prediction_depth(params['value'])
#==SPACE==#

    def set_acceleration(self, params):
        if "acceleration" in params:
            self.acceleration = self.get_actual_thrust(float(params["acceleration"]))
            self.lBodies[self.mark_id].set_acceleration(self.acceleration)
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        if "rotation" in params:
            self.rotation = self.rotation_levels[self.upgrade_level]*float(params["rotation"])*self.power
            self.lBodies[self.mark_id].set_rotation(self.rotation)
#==SPACE==#

#==SPACE==#

    def delete(self):
        super().delete()
        self.lBodies[self.mark_id].self_destruct()
        #self.lBodies.de
#==SPACE==#

#==SPACE==#

#==SPACE==#

class NPC_Kraken_EngineSystem(EngineSystem):
    def get_cooling_speed(self):
        return self.cooling_normal_speed*(1)*self.power

###===###.\back01\modules\ship\systems\sm_interact.py
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.world_constants import WorldPhysConstants
from modules.physEngine.projectiles.projectile_selector import ProjectileSelector
from modules.utils import Command
from modules.physEngine.triggers.collector import TriggerQueue
from modules.ship.systems.sm_core import BasicShipSystem
from modules.ship.shipPool import ShipPool_Singleton
from modules.utils import Command
from modules.utils import Command, CommandQueue, ConfigLoader
#==SPACE==#

#==SPACE==#

class InteractionSystem(BasicShipSystem):
    def __init__(self, mark_id):
        super().__init__(mark_id, "interact_sm")
        self.lBodies = lBodyPool_Singleton()
        self.hp = 300
        self.interaction_radius = 30
#==SPACE==#

    def proceed_command(self, command:Command):
        super().proceed_command(command)
        match command.get_action():
            case 'interact':
                self.interact(command.get_params()["target_id"])
#==SPACE==#

    def get_status(self):
        status = super().get_status()
        status["interactable_objects"]=self.get_available_interactable_objects()
        return status
#==SPACE==#

    def get_available_interactable_objects(self):
        if self.mark_id in self.lBodies.bodies:
            result = []
            available_bodies = self.lBodies[self.mark_id].get_interactble_objects_in_radius(self.interaction_radius)
            for body_idx in available_bodies:
                interact_descr = self.lBodies[body_idx].get_interact_description()
                result.append((body_idx, interact_descr))
            return result
        return []
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def interact(self, target_id):
        TriggerQueue().add("interact", self.mark_id, {
                        "target":target_id,
                        })
        if hasattr(self.lBodies[target_id], "interact"):
            self.lBodies[target_id].interact(self.mark_id)

###===###.\back01\modules\ship\systems\sm_launcher.py
#==SPACE==#

from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.world_constants import WorldPhysConstants
from modules.physEngine.projectiles.projectile_selector import ProjectileSelector
from modules.physEngine.projectiles.projectiles_core import pjtl_Basic, pjtl_Constructed
from modules.ship.shipPool import ShipPool_Singleton
from modules.ship.systems.sm_core import BasicShipSystem
from modules.ship.systems.sm_core import GlobalShipSystemController
from modules.utils import Command, CommandQueue, ConfigLoader
#==SPACE==#

#==SPACE==#

#launch drones, increase launch shafts amount
class LauncherSystem(BasicShipSystem):
    def __init__(self, mark_id):
        super().__init__(mark_id, "launcher_sm")
        self.lBodies = lBodyPool_Singleton()
        self.shafts = {
                        str(k):LauncherSystem_shaft(str(k),self.mark_id) for k in range(self.upgrade_level)
                        }
        self.select_shaft("0")
        self.status = "OK"
        self.auto_toggle = True
        self.auto_reload = False
        self.set_auto_reload(self.auto_reload)
#==SPACE==#

#==SPACE==#

    def set_auto_reload(self, value):
        self.auto_reload = value
        for key in self.shafts:
            self.shafts[key].set_auto_reload(self.auto_reload)
#==SPACE==#

#==SPACE==#

    def upgrade(self):
        super().upgrade()
        if len(self.shafts)<6:
            key = str(len(self.shafts))
            self.shafts[key] = LauncherSystem_shaft(key,self.mark_id)
            self.shafts[key].set_auto_reload(self.auto_reload)
        self.get_system("radar_sm").set_launcher_shafts_amount(self.get_actual_shafts_number())
        self.update_available_projectile()
#==SPACE==#

    def get_actual_shafts_number(self):
        return len(self.shafts)
#==SPACE==#

    def downgrade(self):
        super().downgrade()
        key = str(len(self.shafts)-1)
        if key in self.shafts:
            self.shafts[key].unload()
            del self.shafts[key]
            self.get_system("radar_sm").set_launcher_shafts_amount(self.get_actual_shafts_number())
#==SPACE==#

    def unload(self):
        for key in self.shafts:
            self.shafts[key].unload()
#==SPACE==#

    def get_status(self):
        shafts_status = {k: self.shafts[k].get_status() for k in self.shafts}
#==SPACE==#

        status = super().get_status()
        status["shafts"] = shafts_status
        status["auto_toggle"] = self.auto_toggle
        status["auto_reload"] = self.auto_reload
        return status
#==SPACE==#

    def proceed_command(self, command:Command):
        super().proceed_command(command)
        if command.contains_level("shaft"):
            shaft_id = command.get_target_id("shaft")
            self.shafts[shaft_id].proceed_command(command)
            return
#==SPACE==#

        match command.get_action():
            case 'select_shaft':
                self.select_shaft(command.get_params()["shaft_id"])
#==SPACE==#

            case 'auto_toggle':
                self.auto_toggle = command.get_params()["active"]
#==SPACE==#

            case 'auto_reload':
                self.set_auto_reload(command.get_params()["active"])
#==SPACE==#

            case "aim":
                for n in self.shafts:
                    params = command.get_params()
                    self.shafts[n].aim(params)
            case "launch":
                succeed = self.shafts[self.selected_shaft].launch()
                if succeed:
                    self.iterate_shaft()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def iterate_shaft(self):
        if self.auto_toggle:
            max_shaft = str(len(self.shafts))
            self.selected_shaft = str(int(self.selected_shaft)+1)
            if self.selected_shaft == max_shaft:
                self.selected_shaft="0"
            self.select_shaft(self.selected_shaft)
#==SPACE==#

#==SPACE==#

    def select_shaft(self, n):
        self.selected_shaft = n
        for k in self.shafts:
            if self.shafts[k].shaft_num ==n: self.shafts[k].select()
            else: self.shafts[k].unselect()
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def next_step(self):
        for k in self.shafts:
            self.shafts[k].next_step(self.power)
#==SPACE==#

    def update_available_projectile(self):
#==SPACE==#

        projectiles = self.get_system("resources_sm").get_available_projectiles()
        for k in self.shafts:
            self.shafts[k].available_projectiles = projectiles
#==SPACE==#

    def initiate(self):
        self.update_available_projectile()
        for k in self.shafts:
            self.shafts[k].initiate()
#==SPACE==#

from modules.ship.systems.sm_damage import CrewSystem
from modules.ship.systems.sm_core import GlobalShipSystemController
from modules.physEngine.solar_flare.solar_flar_defendzone import SolarFlareDefendZone
#класс одной шахты
class LauncherSystem_shaft:
    def __init__(self, shaft_num, master_mark_id) -> None:
        self.lBodies = lBodyPool_Singleton()
        self.master_mark_id = master_mark_id
        self.shaft_num = shaft_num
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.selected = False
        self.projectile = None
#==SPACE==#

        self.available_projectiles = ProjectileSelector.get_projectiles_list()
#==SPACE==#

        self.loading_progress = 0
        self.loading_time = ConfigLoader().get("sm_launcher.reloading_period_sec", float)
        self.auto_reload = True
        self.last_load_params = None
#==SPACE==#
            
        self.launch_params = {
            "vel_angle":0,
            "vel_scalar":0
        }
#==SPACE==#

        self.projectile_templates = {
#==SPACE==#

        }
#==SPACE==#

        self.launch_speed = ConfigLoader().get("sm_launcher.launch_speed", float)
        self._crew_sm = None
#==SPACE==#

#==SPACE==#

    def set_auto_reload(self, value):
        self.auto_reload = value
#==SPACE==#

#==SPACE==#
            
    @property
    def crew_sm(self):
        if not self._crew_sm:
            self.crew_sm = GlobalShipSystemController().get(self.master_mark_id, "crew_sm")
        return self._crew_sm
#==SPACE==#

    @crew_sm.setter
    def crew_sm(self, value):
        self._crew_sm = value
#==SPACE==#

    #one step - ~0.03 sec
    def next_step(self, power):
        if self.projectile:
            if self.projectile.status=="destroyed":
                self.projectile = None
                self.loading_progress = 0
                return
#==SPACE==#

            if self.loading_progress!=100:
                crew_acc= self.crew_sm.get_crew_acceleration_in_system("launcher_sm") if self.crew_sm else 0
                loading_step = WorldPhysConstants().get_onetick_step(100,self.loading_time)*(1+crew_acc)*power
                self.loading_progress = round(min(100, self.loading_progress+loading_step),2)
#==SPACE==#

#==SPACE==#

    def proceed_command(self, command:Command):
        match command.get_action():
            case 'load_projectile':
                self.load(command.get_params())
            case 'set_projectile_params':
                self.set_projectile_params(command.get_params())
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_status(self):
        return {
            "progress":self.loading_progress,
            "selected":self.selected,
            "available_projectiles":self.available_projectiles,
            "loaded_type": self.projectile.type if self.projectile else None,
            "launch_params":self.projectile_templates[self.projectile.type] if self.projectile else {}
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def aim(self, params):
        if self.projectile:
            self.projectile.set_aim(params["vel_angle"], self.launch_speed*params["vel_scalar"])
#==SPACE==#

    def set_projectile_params(self,params):
        if self.projectile:
            self.projectile.set_params(params)
            try:
                if self.projectile.type in self.projectile_templates:
                    for k in params:
                        self.projectile_templates[self.projectile.type][k][-1] = params[k]
            except Exception as e:
                print(repr(e))
#==SPACE==#

    def send_command(self, level, command, params):
        cmd_content = {
            "level":"ship."+level,
            "target_id":self.master_mark_id,
            "action":command,
            "params":params
        }
        cmd_obj = Command(cmd_content)
        CommandQueue().add_command(cmd_obj)
#==SPACE==#

    def launch(self):
        if self.selected:
            if self.projectile:
                if int(self.loading_progress)==100:
                    self.projectile.launch()
                    self.projectile = None
                    self.loading_progress = 0
                    self.launch_params = {}
                    if self.auto_reload:
                        self.load(self.last_load_params)
                    return True
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def return_projectile_to_storage(self):
        resources_sm = GlobalShipSystemController().get(self.master_mark_id, "resources_sm")
        if self.projectile:
            resources_sm.add_resource(self.projectile.pjtl_name,1)
            self.unload()
#==SPACE==#

    def get_projectile_from_storage(self, projectile_type):
        resources_sm = GlobalShipSystemController().get(self.master_mark_id, "resources_sm")
        if not resources_sm.stockpile_items.contains_item(projectile_type): return False
        success = resources_sm.spend_resource(projectile_type,1)
        return success
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    #projectile_type - projectile, mine, drone
    def load(self, params):
        self.last_load_params = params
        self.return_projectile_to_storage()
        if not params["type"]:
            self.unload()
            return
        projectile_type = params["type"].split('[')[0].strip()
        if not self.get_projectile_from_storage(projectile_type): return
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.projectile:pjtl_Basic = ProjectileSelector.get_projectile_by_classname(projectile_type, self.master_mark_id)
        if not self.projectile:
            blueprint = GlobalShipSystemController().get(self.master_mark_id, "resources_sm").get_blueprint(projectile_type)
            self.projectile:pjtl_Constructed = pjtl_Constructed(self.master_mark_id, projectile_type, blueprint)
            if not self.projectile: return
#==SPACE==#

        if self.projectile:
            self.update_template()
#==SPACE==#

            paramset = {}
            for k in self.projectile_templates[self.projectile.type]:
                    paramset[k] = self.projectile_templates[self.projectile.type][k][-1]
            self.projectile.set_params(paramset)
            self.projectile.set_aim(0,0)
            if self.selected: self.show_projectile()
        GlobalShipSystemController().get(self.master_mark_id, "launcher_sm").update_available_projectile()
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def update_template(self):
        projectile_params = self.projectile.get_params_template()
        if self.projectile.type not in self.projectile_templates:
            self.projectile_templates[self.projectile.type] = projectile_params
        else:
            current_template = self.projectile_templates[self.projectile.type]
            for k in projectile_params:
                if k not in current_template:
                    self.projectile_templates[self.projectile.type] = projectile_params
                    return
                if projectile_params[k][:-1]!=current_template[k][:-1]:
                    self.projectile_templates[self.projectile.type] = projectile_params
                    return
            for k in current_template:
                if k not in projectile_params:
                    self.projectile_templates[self.projectile.type] = projectile_params
                    return
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

#==SPACE==#
                    
#==SPACE==#

    def unload(self):
        self.hide_projectile()
        self.projectile = None
        self.loading_progress = 0
        self.launch_params = {}
#==SPACE==#

    #only visual via LBody Singleton
    def select(self):
        if self.selected: return
        self.selected = True
        self.show_projectile()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def unselect(self):
        if not self.selected: return
        self.selected = False
        self.hide_projectile()
#==SPACE==#

#==SPACE==#

    def show_projectile(self):
        if self.projectile: self.lBodies.add(self.projectile)
#==SPACE==#

    def hide_projectile(self):
#==SPACE==#
        
        if self.projectile: 
#==SPACE==#
            
            flare_defended = self.projectile.mark_id in SolarFlareDefendZone().entities
            self.lBodies.delete(self.projectile.mark_id)
            if flare_defended:
                SolarFlareDefendZone().add(self.projectile.mark_id)
#==SPACE==#

#==SPACE==#

class XenoBeast_Launcher:
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def get_status(self):
        shafts_status = {k: self.shafts[k].get_status() for k in self.shafts}
        status = super().get_status()
        status["shafts"] = shafts_status
        status["auto_toggle"] = self.auto_toggle
        status['xeno_beast'] = True
        return status
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#

    def proceed_command(self, command:Command):
        super().proceed_command(command)
        if command.contains_level("shaft"):
            shaft_id = command.get_target_id("shaft")
            self.shafts[shaft_id].proceed_command(command)
            return

###===###.\back01\modules\ship\systems\sm_medicine.py
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.world_constants import WorldPhysConstants
from modules.physEngine.projectiles.projectile_selector import ProjectileSelector
from modules.ship.systems.sm_core import BasicShipSystem
from modules.ship.shipPool import ShipPool_Singleton
from modules.utils import Command, CommandQueue, ConfigLoader
from modules.ship.systems.sm_core import GlobalShipSystemController
from random import *
from datetime import datetime, timedelta
#==SPACE==#

#==SPACE==#

class PlaguePhase:
        def __init__(self, name, next_phase, duration_sec, effect,) -> None:
#==SPACE==#

#==SPACE==#
                
            self.name: str = name
            self.next_phase: str = next_phase
            self.effect: dict = effect
            self.duration_sec: int = duration_sec
            self.ttl: int = int(WorldPhysConstants().get_ticks_per_second()*self.duration_sec)
#==SPACE==#

        def run(self):
            self.ttl = WorldPhysConstants().get_ticks_per_second()*self.duration_sec
#==SPACE==#

        def is_over(self):
            return self.ttl==0
#==SPACE==#

#==SPACE==#
            
        def next_step(self):
            self.ttl = max(0,self.ttl-1)
#==SPACE==#

        def time2next(self):
            return round(self.ttl/WorldPhysConstants().get_ticks_per_second())
#==SPACE==#
        
#==SPACE==#

#==SPACE==#

class PlagueController:
    def __init__(self):
        self.current_phase = None
#==SPACE==#

        self.plague_phase_sec = ConfigLoader().get("sm_med.plague_phase_min", float)
        plague_phase_degradation = ConfigLoader().get("sm_med.plague_phase_degradation", float)
        plague_min_step = WorldPhysConstants().get_onetick_step(plague_phase_degradation,self.plague_phase_sec) #*60
#==SPACE==#

        self.phases = {
            #здоров
            None: PlaguePhase(name = None, next_phase=None, duration_sec=self.plague_phase_sec,                      effect={"HP":0, "MP":0}),
#==SPACE==#

            #первая фаза инкубации
            "incubation":PlaguePhase(name = "incubation", next_phase="predromal", duration_sec=self.plague_phase_sec,                effect={"HP":0, "MP":0}),
#==SPACE==#
            
            #усиливает усталость
            "predromal":PlaguePhase(name = "predromal", next_phase="active", duration_sec=self.plague_phase_sec, effect={"HP":0, "MP":-plague_min_step}),
#==SPACE==#

            #снимает хиты и усталость
            "active":PlaguePhase(name = "active", next_phase="active_terminal", duration_sec=self.plague_phase_sec,              effect={"HP":-plague_min_step, "MP":-plague_min_step}),
#==SPACE==#

            #снимакт хиты и усталость вдвое быстрее
            "active_terminal":PlaguePhase(name = "active_terminal", next_phase="active_terminal", duration_sec=self.plague_phase_sec,                effect={"HP":-2*plague_min_step, "MP":-2*plague_min_step}),
#==SPACE==#

#==SPACE==#
            
            "active_regen":PlaguePhase(name = "active_regen", next_phase="active_regen_terminal", duration_sec=self.plague_phase_sec,        effect={"HP":None, "MP":-plague_min_step}),
#==SPACE==#

            "active_regen_terminal":PlaguePhase(name = "active_regen_terminal", next_phase="active_regen_terminal", duration_sec=self.plague_phase_sec,             effect={"HP":None, "MP":-plague_min_step*2}),
#==SPACE==#

            "active_mental":PlaguePhase(name = "active_mental", next_phase="active_mental_terminal", duration_sec=self.plague_phase_sec, effect={"HP":-plague_min_step, "MP":None}),
#==SPACE==#

            "active_mental_terminal":PlaguePhase(name = "active_mental_terminal", next_phase="active_mental_terminal", duration_sec=self.plague_phase_sec,             effect={"HP":-plague_min_step*2, "MP":None}),
        }
#==SPACE==#

    def get_description(self):
        result = {
            "phase":self.current_phase,
            "time2next":self.phases[self.current_phase].ttl
        }
        return result
#==SPACE==#

#==SPACE==#

    def put_description(self, descr):
        self.current_phase = descr['phase']
        self.phases[self.current_phase].ttl = descr["time2next"]
#==SPACE==#

    def get_status(self):
        result = {
            "phase":None,
            "time2next":None
        }
        if self.current_phase:
            result['phase'] = self.current_phase
            result['time2next'] = self.phases[self.current_phase].time2next()
        return result
#==SPACE==#

    def next_step(self):
        if self.current_phase:
            current_phase_obj = self.phases[self.current_phase]
            current_phase_obj.next_step()
            if current_phase_obj.is_over():
                self.current_phase = current_phase_obj.next_phase
                self.phases[self.current_phase].run()
        return self.phases[self.current_phase].effect
#==SPACE==#

    def set_phase(self, phase):
        self.current_phase = phase
        self.phases[phase].run()
#==SPACE==#

    def proceed_command(self, cmd: Command):
        action = cmd.get_action()
        params = cmd.get_params()
        match action:
            case "set_plague_phase":
                self.set_phase(params["phase"])
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
from math import ceil
class HealthAxisController:
    def __init__(self):
        self.value = 8
        self.next_step_mod = 0
        self.normal_interval = [8,8]
        self.light_damage = [5,7]
        self.heavy_damage = [2,4]
        self.frozen = False
        self.crit_state = False
        self.crit_timestamp = None
        self.crit_duration = ConfigLoader().get("sm_med.critical_state_duration_min",float)*WorldPhysConstants().get_ticks_per_second() #60*
#==SPACE==#

    def set_next_step_mod(self, value):
        self.frozen = False
        self.next_step_mod = value
        if value == None:
            self.frozen = True
            self.next_step_mod = 0
#==SPACE==#
        
#==SPACE==#

    def get_value(self):
        return ceil(self.value)
#==SPACE==#

    def add_points(self, value):
        self.value = self.value+value
        if self.value>9: self.value = 9
        if self.value<1: self.value = 1
#==SPACE==#

    def apply_light_cure(self):
        if self.light_damage[0]<=self.value<=self.light_damage[1]:
            self.value = randint(self.normal_interval[0],self.normal_interval[1])
#==SPACE==#

    def apply_hard_cure(self):
        if self.heavy_damage[0]<=self.value<=self.heavy_damage[1]:
            self.value = randint(self.light_damage[0],self.light_damage[1])
#==SPACE==#

    def apply_crit_cure(self):
        if self.value == 1:
            self.value = randint(self.heavy_damage[0],self.heavy_damage[1])
            self.set_crit_state(False)
#==SPACE==#

    def set_crit_state(self, value):
        if value:
            if not self.crit_timestamp:
                self.crit_timestamp = WorldPhysConstants().current_frame()
        else:
            self.crit_timestamp = None
        self.crit_state = value
#==SPACE==#

    def next_step(self):
        self.value = max(1, self.next_step_mod+self.value)
        self.value = min(9, self.value)
        if self.value==1:
            self.set_crit_state(True)
        if self.crit_state:
            if WorldPhysConstants().current_frame() > self.crit_timestamp+self.crit_duration:
                self.crit_state = False
                self.crit_timestamp = None
                self.apply_crit_cure()
#==SPACE==#

class MPAxisController(HealthAxisController):
    def __init__(self):
        super().__init__()
        self.normal_interval = [6,8]
        self.light_damage = [4,5]
        self.heavy_damage = [2,3]
        self.logged_in = False
        fatigue_phase_min = ConfigLoader().get("sm_med.fatigue_phase_min", float)
        fatigue_phase_degradation = ConfigLoader().get("sm_med.fatigue_phase_degradation", float)
        self.fatigue_step = WorldPhysConstants().get_onetick_step(fatigue_phase_degradation,fatigue_phase_min)
#==SPACE==#

    def log_in(self):
        self.logged_in = True
#==SPACE==#

    def log_out(self):
        self.logged_in = False
#==SPACE==#

    #основной метод, отсчитывающий такты состояний
    def next_step(self):
        super().next_step()
        if self.logged_in:
            self.value = max(self.value-self.fatigue_step,1)
#==SPACE==#

class HPAxisController(HealthAxisController):
    def apply_wound(self):
        if self.frozen: return
        if 8<self.value <=9:
            self.value = 8
        if 7<self.value <=8:
            self.value = randint(self.light_damage[0],self.light_damage[1])
        elif self.light_damage[0]<=self.value<=self.light_damage[1]:
            self.value = randint(self.heavy_damage[0],self.heavy_damage[1])
        elif self.value<=self.heavy_damage[1]:
            self.value = 1
#==SPACE==#

class HealthStateController:
    def __init__(self):
        self.HP = HPAxisController()
        self.MP = MPAxisController()
        self.plague_controller = PlagueController()
#==SPACE==#

        self.logged_in = False
#==SPACE==#

        #блок про то, сколько висит плашка "вы ранены"
        self.wounded = False
        self.wound_timestamp = None
        self.wound_disability_period = timedelta(seconds=ConfigLoader().get("sm_med.wound_disability_period", float))
#==SPACE==#

        #раз во сколько времени в игрока может прилететь ранение
        self.is_vulnerable = True
        self.unvulnerability_period_min = timedelta(minutes=ConfigLoader().get("sm_med.unvulnerability_period_min", float))
#==SPACE==#

        #через сколько после лечения можно повторно вводить лекарства
        self.can_be_cured = True
        self.cure_timestamp = None
        self.cure_reabilitation_period_min = timedelta(seconds=ConfigLoader().get("sm_med.cure_reabilitation_period_min", float))
#==SPACE==#

    def is_vulnerable_f(self):
        if not self.logged_in:
            return False
        return self.is_vulnerable
#==SPACE==#

    def get_description(self):
        return {
            "HP":self.HP.value,
            "MP":self.MP.value,
            "plague": self.plague_controller.get_description(),
        }
#==SPACE==#
    
    def put_description(self, descr):
        self.HP.value = descr["HP"]
        self.MP.value = descr["MP"]
        self.plague_controller.put_description(descr["plague"])
#==SPACE==#

    def get_state(self):
        return {
            "HP":self.HP.get_value(),
            "MP":self.MP.get_value(),
            "plague": self.plague_controller.get_status(),
            "disabled": self.wounded,
            "can_be_cured": self.can_be_cured
        }
#==SPACE==#

    def set_wounded(self, state):
        if state:
            self.wound_timestamp = datetime.now()
        else:
            self.wound_timestamp = None
        self.wounded = state
#==SPACE==#

    def update_wounded(self):
        if self.wound_timestamp:
            if self.wound_timestamp+self.wound_disability_period<datetime.now():
                self.set_wounded(False)
#==SPACE==#

#==SPACE==#

    def set_can_be_cured(self,state):
        if state:
            self.cure_timestamp = None
        else:
            self.cure_timestamp = datetime.now() 
        self.can_be_cured = state
#==SPACE==#

    def update_can_be_cured_state(self):
        if self.cure_timestamp:
            if self.cure_timestamp+self.cure_reabilitation_period_min<datetime.now():
                self.set_can_be_cured(True)
#==SPACE==#

    def set_vulnerable(self, state):
        self.is_vulnerable = state
#==SPACE==#

    def get_controller(self, scale):
        if scale == "MP":
            return self.MP
        return self.HP
#==SPACE==#

#==SPACE==#
        
    def log_in(self):
        self.logged_in = True
        self.MP.log_in()
#==SPACE==#

    def log_out(self):
        self.logged_in = False
        self.MP.log_out()
#==SPACE==#

    def add_points(self, scale, points):
        controller:HealthAxisController = self.get_controller(scale)
        controller.add_points(points)
#==SPACE==#

    def apply_light_cure(self, scale):
        controller:HealthAxisController = self.get_controller(scale)
        controller.apply_light_cure()
        self.set_can_be_cured(False)
#==SPACE==#

    def apply_hard_cure(self, scale):
        controller:HealthAxisController = self.get_controller(scale)
        controller.apply_hard_cure()
        self.set_can_be_cured(False)
#==SPACE==#

    def apply_crit_cure(self, scale):
        controller:HealthAxisController = self.get_controller(scale)
        controller.apply_crit_cure()
        self.set_can_be_cured(False)
#==SPACE==#

    def apply_wound(self):
        self.HP.apply_wound()
        self.set_wounded(True)
#==SPACE==#

    def next_step(self):
        effects = self.plague_controller.next_step()
        if effects["HP"] == None:
            self.set_vulnerable(False)
        else:
            self.set_vulnerable(True)
        self.MP.set_next_step_mod(effects["MP"])
        self.HP.set_next_step_mod(effects["HP"])
        self.MP.next_step()
        self.HP.next_step()
        self.update_wounded()
        self.update_can_be_cured_state()
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

class MedicineSystem(BasicShipSystem):
    def __init__(self, mark_id):
        super().__init__(mark_id, "med_sm")
        self.capacity = 5
        self.capacity_levels = ConfigLoader().get("sm_med.capacity_levels", list)
        self.crew_units = 0
#==SPACE==#

        self.crew_unit_healing_progress = 0
        self.crew_unit_healing_progress_max = 100
        self.crew_unit_healing_duration = ConfigLoader().get("sm_med.crew_unit_healing_duration", float)
        self.crew_unit_healing_step = WorldPhysConstants().get_onetick_step(100,self.crew_unit_healing_duration)
        self.active = True
#==SPACE==#

        self.roles = {
            "captain":HealthStateController(),
            "navigator":HealthStateController(),
            "cannoneer":HealthStateController(),
            "engineer":HealthStateController(),
            "medic":HealthStateController(),
        }
        self._crew_sm = None
#==SPACE==#

#==SPACE==#

    def get_description(self):
        result = super().get_description()
        result["crew_units"] = self.crew_units
        result["roles"] = {
            role:self.roles[role].get_description() for role in self.roles
        }
        return result
#==SPACE==#

    def put_description(self, descr):
        super().put_description(descr)
        self.crew_units = descr["crew_units"]
        for role in descr["roles"]:
            self.roles[role].put_description(descr["roles"][role])
#==SPACE==#

#==SPACE==#
            
    def upgrade(self):
        super().upgrade()
        self.capacity = self.capacity_levels[self.upgrade_level]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def downgrade(self):
        super().downgrade()
        self.capacity = self.capacity_levels[self.upgrade_level]
        if self.crew_units>self.capacity:
            self.crew_units = self.capacity
#==SPACE==#

    @property
    def crew_sm(self):
        if not self._crew_sm:
            self.crew_sm = GlobalShipSystemController().get(self.mark_id, "crew_sm")
        return self._crew_sm
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    @crew_sm.setter
    def crew_sm(self, value):
        self._crew_sm = value
#==SPACE==#

    def get_status(self):
        res = super().get_status()
        res = {"roles":{}, "hospital":{}}
        for a in self.roles:
            res["roles"][a] = self.roles[a].get_state()
        res["hospital"]["capacity"] = int(self.capacity)
        res["hospital"]["units"] = self.crew_units
        res["hospital"]["progress"] = self.crew_unit_healing_progress
        return res
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_random_vulnerable_role(self):
        available = []
        for role in ["captain"]:#, "navigator", "cannoneer", "engineer"]:
            if self.roles[role].is_vulnerable_f():
                available.append(role)
        if available:
            return choice(available)
        else:
            return None
#==SPACE==#

    def add_unit_to_hospital(self, value):
        self.crew_units=min(self.crew_units+value, self.capacity)
        role_to_wound = self.get_random_vulnerable_role()
        if role_to_wound:
            self.roles[role_to_wound].apply_wound()
#==SPACE==#

    def remove_unit_from_hospital(self, value):
        if self.crew_units>=value:
            self.crew_units = self.crew_units-value
            self.crew_sm.add_unit_to_crew(value)
#==SPACE==#

    def npc_crew_cure_step(self):
        if self.active:
            if self.crew_units>0:
                if self.crew_unit_healing_progress<self.crew_unit_healing_progress_max:
                    healing_step = self.get_healing_step()
                    self.crew_unit_healing_progress = min(self.crew_unit_healing_progress+healing_step,
                                                          self.crew_unit_healing_progress_max)
                else:
                    self.crew_unit_healing_progress = 0
                    self.remove_unit_from_hospital(1)
#==SPACE==#

    def get_healing_step(self):
        crew_acc= self.crew_sm.get_crew_acceleration_in_system("resources_sm") if self.crew_sm else 0
        power = self.get_system("resources_sm").power
        return self.crew_unit_healing_step*(1+crew_acc)*power
#==SPACE==#
         
#==SPACE==#

    def proceed_command(self, cmd: Command):
        action = cmd.get_action()
        params = cmd.get_params()
#==SPACE==#

        if cmd.contains_level("plague"):
            role = params['role']
            self.roles[role].plague_controller.proceed_command(cmd)
            return
#==SPACE==#

#==SPACE==#
            
        match action:
            case 'set_activity':
                self.active = params["value"]
            case 'toogle_activity':
                self.active = not self.active
            case "remove_unit_from_hospital": self.remove_unit_from_hospital(params['value'])
            case "disable_user":
                self.roles[params['role']].set_disable(params['role'], True)
#==SPACE==#

            case "restore_user":
                self.roles[params['role']].set_disable(params['role'], False)
#==SPACE==#

            case 'apply_light_cure':
                self.roles[params['role']].apply_light_cure(params['axis'])
            case 'apply_hard_cure':
                self.roles[params['role']].apply_hard_cure(params['axis'])
            case 'apply_crit_cure':
                self.roles[params['role']].set_can_be_cured(False)
#==SPACE==#

            case 'add_points':
                self.roles[params['role']].add_points(params['axis'], params["value"])
#==SPACE==#

            case 'apply_wound':
                self.roles[params['role']].apply_wound()
#==SPACE==#

#==SPACE==#
                
            case "log_in":
                if params['role']=="medic": return
                self.roles[params['role']].log_in()
#==SPACE==#

            case "log_out":
                self.roles[params['role']].log_out()
#==SPACE==#

#==SPACE==#
    
#==SPACE==#

#==SPACE==#

    def next_step(self):
        super().next_step()
        for role in self.roles:
            self.roles[role].next_step()
        self.npc_crew_cure_step()

###===###.\back01\modules\ship\systems\sm_radar.py
from modules.ship.systems.sm_core import BasicShipSystem
from modules.physEngine.core import lBodyPool_Singleton, CalculationUtilites
from modules.utils import Command, ConfigLoader,PerformanceCollector, get_dt_ms
from datetime import timedelta
from datetime import datetime
import math
#==SPACE==#

class RadarSystem(BasicShipSystem):
    def __init__(self, mark_id):
        super().__init__(mark_id, "radar_sm")
        self.lBodies = lBodyPool_Singleton()
        self.basic_close = ConfigLoader().get("sm_radar.basic_close_range", float)
        self.add_close = ConfigLoader().get("sm_radar.add_close_range_per_upgrade_level", float)
        self.basic2distant_coef = ConfigLoader().get("sm_radar.basic2distant_coef", float)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.radar_ping = timedelta(seconds=ConfigLoader().get("sm_radar.ping_time", float))
        self.energy_magnitude = 0
        self.launcher_shafts_amount = 0
#==SPACE==#

    def get_status(self):
        res = super().get_status()
        res["close_range"] = self.lBodies.bodies[self.mark_id].close_scanrange
        res["distant_range"] = self.lBodies.bodies[self.mark_id].distant_scanrange
        res["distant_dir"] = self.lBodies.bodies[self.mark_id].distant_scanrange_dir
        res["distant_arc"] = self.lBodies.bodies[self.mark_id].distant_scanrange_arc
        return res
#==SPACE==#

    def proceed_command(self, cmd: Command):
        super().proceed_command(cmd)
        action = cmd.get_action()
        params = cmd.get_params()
        match action:
            case "set_radar_arc":
                self.set_radar_params(params["radar_arc"], None)
            case "set_radar_dir":
                self.set_radar_params(None, params["radar_dir"])
#==SPACE==#

    def upgrade(self):
        super().upgrade()
        self.update_scanrange()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def downgrade(self):
        super().downgrade()
        self.update_scanrange()
#==SPACE==#

    def get_actual_close_scanrange(self):
        return self.basic_close+self.add_close*self.upgrade_level
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_maximal_distant_scanrange(self):
        close_range = self.get_actual_close_scanrange()
        return close_range+close_range*self.basic2distant_coef*self.power
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_actual_distant_scanrange(self, arc = None):
        distance = self.get_maximal_distant_scanrange()
        sectorArea = 3.1415*distance*distance
        radar_arc_rad = CalculationUtilites.degress2rads(self.lBodies.bodies[self.mark_id].distant_scanrange_arc)
        if arc:
            radar_arc_rad = CalculationUtilites.degress2rads(arc)
        new_distance = math.sqrt(sectorArea/radar_arc_rad)
        return new_distance
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def update_scanrange(self):
        self.lBodies.bodies[self.mark_id].set_close_scanrange(self.get_actual_close_scanrange())
        self.lBodies.bodies[self.mark_id].set_distant_scanrange(self.get_actual_distant_scanrange())
        self.update_visibility()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    def set_power(self, value):
        super().set_power(value)
        self.update_scanrange()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    #вызывается из базового класса корабля
    def get_nav_data(self):
        nav_data = self.lBodies.bodies[self.mark_id].get_nav_data(self.radar_ping)
        return nav_data
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    #radar_arc in angles
    def set_radar_params(self, radar_arc, radar_dir):
        new_distance = self.get_actual_distant_scanrange(radar_arc)
        self.lBodies.bodies[self.mark_id].set_distant_scanparams(new_distance, radar_arc, radar_dir)
#==SPACE==#

    #вызывается из реактора на каждое изменение уровня энергии в любой системе
    def change_energy_magnitude(self, step):
        self.energy_magnitude = self.energy_magnitude+step
        self.update_visibility()
#==SPACE==#

    #вызывается из лаунчера на каждое добавление/удаление пусковой шахты
    def set_launcher_shafts_amount(self, amount):
        self.launcher_shafts_amount = amount
        self.update_visibility()
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def update_visibility(self):
        visibility = (self.launcher_shafts_amount + self.energy_magnitude)*2/19
        self.lBodies.bodies[self.mark_id].set_visibility(visibility)
#==SPACE==#

#==SPACE==#

#==SPACE==#

class NPC_RadarSystem(BasicShipSystem):
    pass

###===###.\back01\modules\ship\systems\sm_resources.py
from modules.physEngine.core import lBodyPool_Singleton
from modules.physEngine.world_constants import WorldPhysConstants
from modules.physEngine.projectiles.projectile_selector import ProjectileSelector
from modules.utils import Command
from modules.physEngine.projectiles.projectiles_core import pjtl_Constructed
from modules.ship.systems.sm_core import BasicShipSystem
from modules.utils import Command
from modules.utils import Command, CommandQueue, ConfigLoader
from modules.ship.systems.sm_core import GlobalShipSystemController
#==SPACE==#

from queue import Queue
#==SPACE==#

from modules.ship.projectile_blueprints import ProjectileConstructorController
import itertools
#==SPACE==#

class Item:
    def __init__(self):
        self.volume = 0
        self.cost = 0
#==SPACE==#

class Stockpile:
    def __init__(self):
        self.storage = {}
        self.capacity = 10001
        self.occupied = 0
        self.items_volume = {}
        self.items_cost = {}
#==SPACE==#

    def set_capacity(self, value):
        if value<self.occupied:
            self.throw_out_of_volume(self.occupied-value)
        self.capacity = value
#==SPACE==#

#==SPACE==#

    def get_description(self):
        return {
            "storage":self.storage,
            "capacity":self.capacity,
            "occupied":self.occupied,
            "items_volume":self.items_volume,
            "items_cost":self.items_cost,
        }
#==SPACE==#
    
    def put_description(self, descr):
        self.storage = descr["storage"]
        self.capacity = descr["capacity"]
        self.occupied = descr["occupied"]
        self.items_volume = descr["items_volume"]
        self.items_cost = descr["items_cost"]
#==SPACE==#

    def throw_out_of_volume(self, value):
        to_out = {item:0 for item in self.items_volume}
        tmp_val = 0
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        items_it = itertools.cycle(self.items_volume)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        while tmp_val<value:
            item = next(items_it)
            tmp_val = tmp_val+self.items_volume[item]
            to_out[item] = to_out[item]+1
#==SPACE==#

        for item in to_out:
            self.take_item(item, to_out[item])
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
                
#==SPACE==#

#==SPACE==#

    def can_be_placed(self, item_name, item_amount):
        return self.capacity - self.occupied >= self.items_volume[item_name]*item_amount
#==SPACE==#

    def init_item(self,item_name,item_volume, item_cost):
        self.storage[item_name] = 0
        self.items_volume[item_name] = item_volume
        self.items_cost[item_name] = item_cost
#==SPACE==#

    def get_volume_and_cost(self, item_name):
        return self.items_volume[item_name], self.items_cost[item_name]
#==SPACE==#

    def add_item(self, item_name, item_amount):
        if item_name not in self.storage: return False
        if not self.can_be_placed(item_name, item_amount):
            free_volume = self.capacity - self.occupied
            item_amount = free_volume//self.items_volume[item_name]
            if item_amount == 0: return False
#==SPACE==#

#==SPACE==#

#==SPACE==#
                
        item_volume = self.items_volume[item_name]*item_amount
        self.storage[item_name] = self.storage[item_name]+item_amount
        self.occupied = self.occupied + item_volume
        return True
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def take_item(self, item_name, item_amount):
        if item_name not in self.storage: return False
        if self.storage[item_name] < item_amount: return False
        self.storage[item_name] = self.storage[item_name]-item_amount
        self.occupied = self.occupied - item_amount*self.items_volume[item_name]
        return True
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def del_item(self, item_name):
        amount = self.storage[item_name]
        self.take_item(item_name, amount)
        self.storage.pop(item_name)
        self.items_volume.pop(item_name)
        self.items_cost.pop(item_name)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def get_status(self):
        return {
            "storage":self.storage,
            "capacity": self.capacity,
            "self.occupied": self.occupied
        }
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def contains_item(self, item_name):
        try:
            return self.storage[item_name]>0
        except Exception as e:
            print("Stockpile.contains_item",repr(e))
        return False
#==SPACE==#

    def get_str_repr(self):
        result = []
        for item_name in self.storage:
            result.append(item_name+f" [{self.storage[item_name]}]")
        return result
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

class ProductionTask:
    def __init__(self, item_name, production_volume):
        self.item_name = item_name
        self.production_volume = production_volume
        self.producted = 0
        self.complete = False
#==SPACE==#

    def step(self, production_step):
        self.producted = min(self.producted+production_step, self.production_volume)
        self.complete = self.producted==self.production_volume
#==SPACE==#

    def get_progress(self):
        return self.producted/self.production_volume
#==SPACE==#

class ProductionQueue:
    def __init__(self):
        self.queue = []
#==SPACE==#

    def add(self, item_name):
        if self.queue!=[]:
            if self.queue[-1][0]==item_name:
                self.queue[-1][1] = self.queue[-1][1]+1
                return
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.queue.append([item_name,1])
#==SPACE==#

    def is_empty(self):
        return self.queue==[]
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_item_by_idx(self, item_idx):
        item_name = self.queue[item_idx][0]
        if item_idx==0:
            if self.queue[item_idx][1] == 1:
                self.queue = self.queue[1:]
                return item_name
        self.queue[item_idx][1]=self.queue[item_idx][1]-1
#==SPACE==#

        if self.queue[item_idx][1]==0:
            self.queue.pop(item_idx)
        return item_name
#==SPACE==#

    def get_next_item(self):
        if self.queue==[]: return None
        return self.get_item_by_idx(0)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
    def remove(self, item_name, item_idx):
        item_idx = int(item_idx)
        if self.queue[int(item_idx)][0]==item_name:
            self.get_item_by_idx(item_idx)
#==SPACE==#

#==SPACE==#

    def clear(self):
        self.queue=[]
#==SPACE==#

from modules.ship.systems.sm_damage import CrewSystem
from modules.ship.systems.sm_core import GlobalShipSystemController
#==SPACE==#

#==SPACE==#

class ResourcesSystem(BasicShipSystem):
    def __init__(self, mark_id, NPC = False):
        super().__init__(mark_id,"resources_sm")
        self.capacity_levels = ConfigLoader().get("sm_resources.capacity_levels", list)
#==SPACE==#

        self.NPC = NPC
        self.stockpile_raw = Stockpile()
        self.stockpile_raw.init_item("metal", 1, 1)
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

        self.stockpile_items = Stockpile()
#==SPACE==#

        self.projectile_constructor = ProjectileConstructorController()
        self.projectile_constructor.initiate_ship_blueprints(self.mark_id)
        self.update_blueprints()
#==SPACE==#

#==SPACE==#

#==SPACE==#
            
        self.production_queue = ProductionQueue()
        self.production_step = WorldPhysConstants().get_onetick_step(5, 5)
        self.production_task:ProductionTask = None
        self._crew_sm:CrewSystem = None
#==SPACE==#

        #self.stockpile_items.set_capacity(self.capacity_levels[self.upgrade_level])
        #self.stockpile_raw.set_capacity(self.capacity_levels[self.upgrade_level])
        #self.stockpile_raw.add_item("metal",self.capacity_levels[self.upgrade_level])
#==SPACE==#

        self.stockpile_raw.add_item("metal",10000)
#==SPACE==#

#==SPACE==#

    def get_description(self):
        result = super().get_description()
        result['materials_row'] = self.stockpile_raw.get_description()
        result['stockpile_items'] = self.stockpile_items.get_description()
        result['projectile_constructor'] = self.projectile_constructor.get_description(self.mark_id)
        return result
#==SPACE==#

    def put_description(self, descr):
        super().put_description(descr)
        self.stockpile_raw.put_description(descr['materials_row'])
        self.stockpile_items.put_description(descr['stockpile_items'])
        self.projectile_constructor.put_description(self.mark_id, descr['projectile_constructor'])
#==SPACE==#

#==SPACE==#
            
#==SPACE==#

#==SPACE==#

#==SPACE==#

#==SPACE==#
            
#==SPACE==#

    @property
    def crew_sm(self):
        if not self._crew_sm:
            self.crew_sm = GlobalShipSystemController().get(self.mark_id, "crew_sm")
        return self._crew_sm
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    @crew_sm.setter
    def crew_sm(self, value):
        self._crew_sm = value
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
#==SPACE==#

    def update_blueprints(self, bp_name = None):
        bp_list = self.projectile_constructor.get_blueprints_list(self.mark_id)
        if bp_name:
            bp_list = [bp_name]
        for pjtl_name in bp_list:
            cost = self.projectile_constructor.get_cost(self.mark_id, pjtl_name)
            details = self.projectile_constructor.get_volume(self.mark_id, pjtl_name)
            self.stockpile_items.init_item(pjtl_name, details, cost)
#==SPACE==#

            if not self.NPC:
                if len(bp_list)>1:
                    self.stockpile_items.add_item(pjtl_name, 15)
            else:
                    self.stockpile_items.add_item(pjtl_name, 30)
#==SPACE==#

#==SPACE==#

    def next_step(self):
        if self.production_task:
            crew_acc= self.crew_sm.get_crew_acceleration_in_system("engine_sm") if self.crew_sm else 0
            self.production_task.step(self.production_step*self.power*(1+crew_acc))
            if self.production_task.complete:
                self.stockpile_items.add_item(self.production_task.item_name,1)
                self.trigger_launcher_update()
                self.production_task = None
#==SPACE==#

        else:
            item_name = self.production_queue.get_next_item()
            if item_name:
                if (self.stockpile_items.can_be_placed(item_name,1)):
                    item_volume, item_cost = self.stockpile_items.get_volume_and_cost(item_name)
                    if (self.stockpile_raw.storage["metal"]>=item_cost):
                        result = self.spend_resource("metal",item_cost)
                        if result:
                            self.production_task = ProductionTask(item_name, item_volume)
#==SPACE==#

#==SPACE==#

#==SPACE==#

    def get_available_projectiles(self):
        items_list = self.stockpile_items.get_str_repr()
        return items_list
#==SPACE==#

    def get_blueprint(self, blueprint_name):
        return self.projectile_constructor.get_blueprint(self.mark_id, blueprint_name)
#==SPACE==#

#==SPACE==#

#==SPACE==#
        
    def get_status(self):
